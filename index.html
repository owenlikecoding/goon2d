<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Goonerbait 3D Adventure</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      text-align: center;
      font-family: sans-serif;
      background-color: #000;
    }

    canvas {
      background: #89cff0;
      display: block;
      margin: 0 auto;
    }

    #ui-container {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .game-button {
      display: none;
      padding: 10px 20px;
      font-size: 16px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .game-button:hover {
      background: #45a049;
    }

    #restartBtn {
      background: #f44336;
    }

    #restartBtn:hover {
      background: #d32f2f;
    }

    #viewRecordsBtn {
      background: #2196f3;
    }

    #viewRecordsBtn:hover {
      background: #0b7dda;
    }

    #continueBtn {
      background: #ff9800;
    }

    #continueBtn:hover {
      background: #f57c00;
    }

    #dialogBox {
      position: absolute;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      font-family: sans-serif;
      display: none;
      border-radius: 10px;
      border: 2px solid #fff;
      z-index: 100;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
    }

    #recordBoard {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border-radius: 10px;
      display: none;
      z-index: 100;
      border: 2px solid gold;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    }

    #recordBoard h2 {
      margin-top: 0;
      color: gold;
      text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
    }

    #recordList {
      list-style-type: none;
      padding: 0;
      margin: 0;
      text-align: left;
      max-height: 300px;
      overflow-y: auto;
    }

    #recordList li {
      padding: 8px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
    }

    #recordList li:last-child {
      border-bottom: none;
    }

    .record-name {
      font-weight: bold;
    }

    .record-time {
      color: #ffcc00;
    }

    #submitForm {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #submitForm input {
      padding: 8px;
      border-radius: 4px;
      border: none;
    }

    #submitForm button {
      padding: 8px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    #submitForm button:hover {
      background: #45a049;
    }

    #closeRecordBtn {
      margin-top: 15px;
      padding: 8px 15px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    #closeRecordBtn:hover {
      background: #d32f2f;
    }

    #loadingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none;
    }

    #loadingScreen h2 {
      color: white;
      margin-bottom: 20px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    .progress-bar {
      width: 300px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #4caf50, #8bc34a);
      transition: width 0.3s;
    }

    .notification {
      position: absolute;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 200;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .notification.show {
      opacity: 1;
    }

    .minimap {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 200px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid white;
      border-radius: 5px;
      z-index: 50;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    /* Developer mode panel */
    #devPanel {
      position: absolute;
      top: 100px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: #00ff00;
      padding: 15px;
      border-radius: 5px;
      border: 2px solid #00ff00;
      font-family: monospace;
      display: none;
      z-index: 1000;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
    }

    #devPanel h3 {
      margin-top: 0;
      color: #00ff00;
      border-bottom: 1px solid #00ff00;
      padding-bottom: 5px;
    }

    .dev-button {
      background: #333;
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 5px 10px;
      margin: 5px;
      cursor: pointer;
      font-family: monospace;
      transition: background-color 0.2s;
    }

    .dev-button:hover {
      background: #444;
    }

    #devCodeInput {
      background: #222;
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 5px;
      width: 100px;
      font-family: monospace;
      margin-right: 5px;
    }

    /* Visual effects */
    .particle {
      position: absolute;
      background-color: white;
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
    }

    /* Settings panel */
    #settingsPanel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border-radius: 10px;
      display: none;
      z-index: 100;
      border: 2px solid #4caf50;
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
    }

    #settingsPanel h2 {
      margin-top: 0;
      color: #4caf50;
      border-bottom: 1px solid #4caf50;
      padding-bottom: 10px;
    }

    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 15px 0;
    }

    .settings-row label {
      flex: 1;
    }

    .settings-row input[type="range"] {
      flex: 1;
    }

    .settings-row select {
      flex: 1;
      padding: 5px;
      background: #333;
      color: white;
      border: 1px solid #4caf50;
    }

    #closeSettingsBtn {
      margin-top: 15px;
      padding: 8px 15px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
    }

    #closeSettingsBtn:hover {
      background: #45a049;
    }

    /* FPS counter */
    #fpsCounter {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 14px;
      display: none;
    }

    /* Performance indicator */
    #performanceIndicator {
      position: absolute;
      top: 40px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 14px;
      display: none;
    }
  </style>
</head>

<body>
  <canvas id="gameCanvas"></canvas>
  <div id="ui-container">
    <button id="restartBtn" class="game-button">Restart</button>
    <button id="viewRecordsBtn" class="game-button">View Records</button>
    <button id="continueBtn" class="game-button">Continue Game</button>
    <button id="settingsBtn" class="game-button">Settings</button>
  </div>
  <div id="dialogBox"></div>
  <div id="recordBoard">
    <h2>Speedrun Records</h2>
    <ul id="recordList"></ul>
    <div id="submitForm">
      <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
      <button id="submitRecordBtn">Submit Record</button>
    </div>
    <button id="closeRecordBtn">Close</button>
  </div>
  <div id="loadingScreen">
    <h2>Loading Level...</h2>
    <div class="progress-bar">
      <div class="progress-fill"></div>
    </div>
  </div>
  <div id="devPanel">
    <h3>Developer Mode</h3>
    <div>
      <button class="dev-button" id="devLevelOldKingdom">Level 1</button>
      <button class="dev-button" id="devLevelDesert">Level 2</button>
      <button class="dev-button" id="devLevelTundra">Level 3</button>
      <button class="dev-button" id="devLevelCastle">Boss Level</button>
    </div>
    <div style="margin-top: 10px;">
      <button class="dev-button" id="devGodMode">God Mode</button>
      <button class="dev-button" id="devAddCoins">+10 Coins</button>
      <button class="dev-button" id="devGiveGun">Give Gun</button>
    </div>
    <div style="margin-top: 10px;">
      <button class="dev-button" id="devShowInfo">Debug Info</button>
      <button class="dev-button" id="devClose">Close</button>
    </div>
  </div>
  <div id="settingsPanel">
    <h2>Game Settings</h2>
    <div class="settings-row">
      <label for="graphicsQuality">Graphics Quality:</label>
      <select id="graphicsQuality">
        <option value="low">Low</option>
        <option value="medium" selected>Medium</option>
        <option value="high">High</option>
      </select>
    </div>
    <div class="settings-row">
      <label for="musicVolume">Music Volume:</label>
      <input type="range" id="musicVolume" min="0" max="100" value="50">
    </div>
    <div class="settings-row">
      <label for="sfxVolume">SFX Volume:</label>
      <input type="range" id="sfxVolume" min="0" max="100" value="70">
    </div>
    <div class="settings-row">
      <label for="showFPS">Show FPS:</label>
      <input type="checkbox" id="showFPS">
    </div>
    <div class="settings-row">
      <label for="showPerformance">Show Performance:</label>
      <input type="checkbox" id="showPerformance">
    </div>
    <button id="closeSettingsBtn">Save & Close</button>
  </div>
  <div id="fpsCounter">FPS: 60</div>
  <div id="performanceIndicator">Performance: 100%</div>

  <script>
    // ===== GAME ENGINE =====

    // Canvas setup
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Handle window resizing
    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Update camera dimensions
      camera.width = canvas.width;
      camera.height = canvas.height;
    });

    // Game States: 'start', 'loading', 'world', 'talk', 'combat', 'bossFight', 'win', 'over', 'records', 'settings'
    let gameState = "start";

    // Global Speedrun Timer (in ms)
    let speedrunTime = 0;
    let finalTime = 0;
    let lastTime = 0;
    let isPaused = false;

    // Frame rate and time management
    const TARGET_FPS = 60;
    const FRAME_TIME = 1000 / TARGET_FPS;
    let deltaTime = 0;
    let accumulator = 0;
    let fpsArray = [];
    let currentFps = 0;

    // Performance monitoring
    let performanceRatio = 1.0;
    let showPerformanceIndicator = false;
    let lastPerformanceUpdate = 0;
    const PERFORMANCE_UPDATE_INTERVAL = 1000; // Update every second

    // Debug and developer mode
    let isDevMode = false;
    let showDebugInfo = false;
    let godMode = false;

    // Graphics settings
    let graphicsQuality = "medium";
    let showFpsCounter = false;
    let musicVolume = 50;
    let sfxVolume = 70;

    // Game objects
    const player = {
      x: 100,
      y: 300,
      width: 30,
      height: 30,
      speed: 480, // pixels per second (doubled from 240)
      color: "red",
      weapon: "sword",
      hasGun: false,
      health: 100,
      maxHealth: 100,
      invulnerable: false,
      invulnerableTimer: 0,
      invulnerableDuration: 1000,
      coins: 0,
      experience: 0,
      level: 1,
      // Visual effects
      trail: [],
      maxTrailLength: 5,
      // Animation
      animationFrame: 0,
      animationTimer: 0,
      animationSpeed: 150, // ms per frame
    };

    // Secret car object
    const secretCar = {
      x: 0,
      y: 0,
      width: 60,
      height: 30,
      color: "blue",
      found: false,
      render: function (ctx) {
        if (!this.found) return;

        // Car body
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);

        // Car windows
        ctx.fillStyle = "lightblue";
        ctx.fillRect(this.x + 10, this.y - 10, 20, 10);

        // Car wheels
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(this.x + 15, this.y + this.height, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + this.width - 15, this.y + this.height, 8, 0, Math.PI * 2);
        ctx.fill();

        // Headlights
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(this.x + 5, this.y + this.height - 10, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + this.width - 5, this.y + this.height - 10, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    };

    // Camera system
    const camera = {
      x: 0,
      y: 0,
      width: canvas.width,
      height: canvas.height,
      targetX: 0,
      targetY: 0,
      follow: function (target) {
        // Calculate desired camera position (centered on target)
        this.targetX = target.x - this.width / 2 + target.width / 2;
        this.targetY = target.y - this.height / 2 + target.height / 2;

        // Smoothly move camera toward target (easing)
        this.x += (this.targetX - this.x) * 0.1;
        this.y += (this.targetY - this.y) * 0.1;

        // Clamp camera to world bounds - only if currentLevel exists and has width/height
        if (currentLevel && currentLevel.width && currentLevel.height) {
          // Ensure camera doesn't go beyond level boundaries
          this.x = Math.max(0, Math.min(this.x, currentLevel.width - this.width));
          this.y = Math.max(0, Math.min(this.y, currentLevel.height - this.height));
        }
      },
      isVisible: function (obj, padding = 200) {
        // More generous padding and simpler check
        return (
          obj.x + obj.width + padding > this.x &&
          obj.x - padding < this.x + this.width &&
          obj.y + obj.height + padding > this.y &&
          obj.y - padding < this.y + this.height &&
          obj.y - padding < this.y + this.height
        );
      }
    };

    // Game levels
    const levels = [];
    let currentLevel = null;
    let currentLevelIndex = 0;

    // Game objects collections
    let goons = [];
    let coins = [];
    let bullets = [];
    let activeNPCs = [];
    let particles = [];

    // Timers
    let goonTimer = 0;
    let coinTimer = 0;
    let countryNameDisplayTime = 0;
    const COUNTRY_NAME_DISPLAY_DURATION = 3000;

    // Input handling
    const keys = {};
    let dialogActive = false;

    window.addEventListener("keydown", (e) => {
      keys[e.key] = true;

      // Prevent scrolling with arrow keys
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) {
        e.preventDefault();
      }

      handleKeyPress(e.key);
    });

    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });

    function handleKeyPress(key) {
      // Exit dialog with Escape key
      if (key === "Escape" && dialogActive) {
        hideDialog();
        gameState = "world";
      }

      // Start game with RIGHT ARROW
      if (key === "ArrowRight" && gameState === "start") {
        startNewGame();
      }

      // Handle SPACE key for boss fight
      if (key === " " && gameState === "bossFight") {
        attackBoss();
      }

      // Shoot gun in combat
      if (key.toLowerCase() === "s" && (gameState === "combat" || gameState === "world" || gameState === "bossFight") && player.hasGun) {
        shootGun();
      }

      // Interact with NPCs
      if (key.toLowerCase() === "e" && gameState === "world") {
        interactWithNPC();
      }

      // Pause game
      if (key.toLowerCase() === "p" && (gameState === "world" || gameState === "combat" || gameState === "bossFight")) {
        togglePause();
      }

      // Developer mode activation
      if (key === "d" && (gameState === "world" || gameState === "combat" || gameState === "bossFight" || gameState === "start")) {
        promptDevCode();
      }

      // Settings menu
      if (key === "o" && (gameState === "world" || gameState === "combat" || gameState === "bossFight" || gameState === "start")) {
        toggleSettings();
      }

      // Add after the gun shooting code
      if (key.toLowerCase() === "a" && (gameState === "combat" || gameState === "world" || gameState === "bossFight")) {
        useSword();
      }
    }

    function promptDevCode() {
      const code = prompt("Enter developer code:");
      if (code === "8974") {
        isDevMode = true;
        document.getElementById("devPanel").style.display = "block";
        showNotification("Developer Mode Activated");
      }
    }

    function togglePause() {
      isPaused = !isPaused;
      showNotification(isPaused ? "Game Paused" : "Game Resumed");
    }

    function toggleSettings() {
      if (gameState === "settings") {
        closeSettings();
      } else {
        openSettings();
      }
    }

    function openSettings() {
      const prevState = gameState;
      gameState = "settings";
      document.getElementById("settingsPanel").style.display = "block";

      // Set current values
      document.getElementById("graphicsQuality").value = graphicsQuality;
      document.getElementById("musicVolume").value = musicVolume;
      document.getElementById("sfxVolume").value = sfxVolume;
      document.getElementById("showFPS").checked = showFpsCounter;
      document.getElementById("showPerformance").checked = showPerformanceIndicator;

      // Store previous state to return to
      document.getElementById("settingsPanel").dataset.prevState = prevState;
    }

    function closeSettings() {
      // Save settings
      graphicsQuality = document.getElementById("graphicsQuality").value;
      musicVolume = parseInt(document.getElementById("musicVolume").value);
      sfxVolume = parseInt(document.getElementById("sfxVolume").value);
      showFpsCounter = document.getElementById("showFPS").checked;
      showPerformanceIndicator = document.getElementById("showPerformance").checked;

      // Update FPS counter visibility
      document.getElementById("fpsCounter").style.display = showFpsCounter ? "block" : "none";
      document.getElementById("performanceIndicator").style.display = showPerformanceIndicator ? "block" : "none";

      // Apply graphics settings
      applyGraphicsSettings();

      // Return to previous state
      const prevState = document.getElementById("settingsPanel").dataset.prevState || "start";
      gameState = prevState;
      document.getElementById("settingsPanel").style.display = "none";

      // Save settings to localStorage
      saveSettings();
    }

    function saveSettings() {
      const settings = {
        graphicsQuality,
        musicVolume,
        sfxVolume,
        showFpsCounter,
        showPerformanceIndicator
      };
      localStorage.setItem("goonerbaitSettings", JSON.stringify(settings));
    }

    function loadSettings() {
      const savedSettings = localStorage.getItem("goonerbaitSettings");
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        graphicsQuality = settings.graphicsQuality || "medium";
        musicVolume = settings.musicVolume !== undefined ? settings.musicVolume : 50;
        sfxVolume = settings.sfxVolume !== undefined ? settings.sfxVolume : 70;
        showFpsCounter = settings.showFpsCounter || false;
        showPerformanceIndicator = settings.showPerformanceIndicator || false;

        // Apply loaded settings
        document.getElementById("fpsCounter").style.display = showFpsCounter ? "block" : "none";
        document.getElementById("performanceIndicator").style.display = showPerformanceIndicator ? "block" : "none";
        applyGraphicsSettings();
      }
    }

    function applyGraphicsSettings() {
      switch (graphicsQuality) {
        case "low":
          player.maxTrailLength = 0;
          break;
        case "medium":
          player.maxTrailLength = 5;
          break;
        case "high":
          player.maxTrailLength = 10;
          break;
      }
    }

    function shootGun() {
      const direction = getPlayerDirection();

      bullets.push({
        x: player.x + player.width / 2,
        y: player.y + player.height / 2,
        radius: 5,
        speed: 480, // pixels per second (was 8 pixels per frame)
        direction: direction,
        damage: 5,
        color: "black",
        lifetime: 2000, // Bullets disappear after 2 seconds
        timeLeft: 2000,
        fromPlayer: true // Flag to identify player bullets
      });

      // Create muzzle flash particles
      createParticles(
        player.x + player.width / 2 + direction.x * 15,
        player.y + player.height / 2 + direction.y * 15,
        10,
        "orange",
        0.5,
        300
      );
    }

    function useSword() {
      // Get direction for sword swing
      const direction = getPlayerDirection();

      // Create sword swing effect
      createParticles(
        player.x + player.width / 2 + direction.x * 20,
        player.y + player.height / 2 + direction.y * 20,
        15,
        "silver",
        1,
        300
      );

      // Check for enemies in sword range
      for (let i = goons.length - 1; i >= 0; i--) {
        const goon = goons[i];
        const dx = goon.x + goon.width / 2 - (player.x + player.width / 2);
        const dy = goon.y + goon.height / 2 - (player.y + player.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 60) { // Sword range
          goon.health -= 2; // Sword does 2 damage

          // Create hit particles
          createParticles(
            goon.x + goon.width / 2,
            goon.y + goon.height / 2,
            5,
            "silver",
            0.5,
            300
          );

          if (goon.health <= 0) {
            // Create death particles
            createParticles(
              goon.x + goon.width / 2,
              goon.y + goon.height / 2,
              15,
              "black",
              1,
              800
            );

            // Drop a coin when goon dies (50% chance)
            if (Math.random() > 0.5) {
              coins.push({
                x: goon.x + goon.width / 2 - 10,
                y: goon.y + goon.height / 2 - 10,
                width: 20,
                height: 20,
                color: "gold",
                // Animation
                animationFrame: 0,
                animationTimer: 0,
                animationSpeed: 150,
              });
            }
            goons.splice(i, 1);
          }
        }
      }
    }

    function getPlayerDirection() {
      // Default direction (right)
      const direction = { x: 1, y: 0 };

      // Calculate direction based on key presses
      if (keys["ArrowUp"]) direction.y = -1;
      if (keys["ArrowDown"]) direction.y = 1;
      if (keys["ArrowLeft"]) direction.x = -1;
      if (keys["ArrowRight"]) direction.x = 1;

      // Normalize direction vector
      const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
      if (magnitude > 0) {
        direction.x /= magnitude;
        direction.y /= magnitude;
      }

      return direction;
    }

    function attackBoss() {
      if (!currentLevel || !currentLevel.boss) return;

      const distance = Math.sqrt(
        Math.pow(currentLevel.boss.x + currentLevel.boss.width / 2 - (player.x + player.width / 2), 2) +
        Math.pow(currentLevel.boss.y + currentLevel.boss.height / 2 - (player.y + player.height / 2), 2)
      );

      if (distance < 100) {
        // Player must be close to boss to damage it
        currentLevel.boss.hp -= 1;

        // Visual feedback
        currentLevel.boss.color = "red";
        setTimeout(() => {
          if (currentLevel && currentLevel.boss) {
            currentLevel.boss.color = "purple";
          }
        }, 100);

        // Create hit particles
        createParticles(
          currentLevel.boss.x + currentLevel.boss.width / 2,
          currentLevel.boss.y + currentLevel.boss.height / 2,
          15,
          "red",
          1,
          500
        );

        if (currentLevel.boss.hp <= 0) {
          // Create explosion particles
          createParticles(
            currentLevel.boss.x + currentLevel.boss.width / 2,
            currentLevel.boss.y + currentLevel.boss.height / 2,
            50,
            "purple",
            2,
            1500
          );

          gameState = "win";
          finalTime = speedrunTime;
          document.getElementById("viewRecordsBtn").style.display = "inline-block";
          document.getElementById("restartBtn").style.display = "inline-block";
          saveGameProgress({ completed: true });
        }
      }
    }

    function interactWithNPC() {
      activeNPCs.forEach((npc) => {
        if (checkCollision(player, npc)) {
          if (npc.type === "shop") {
            handleShopInteraction(npc);
          } else {
            showDialog(npc.dialog);
          }
        }
      });
    }

    function handleShopInteraction(npc) {
      if (player.coins >= npc.cost && !player.hasGun) {
        player.coins -= npc.cost;
        player.hasGun = true;
        showDialog("You bought a gun! Use it with 'S' in combat.");
        saveGameProgress();
      } else if (player.hasGun) {
        showDialog("You already own a gun.");
      } else {
        showDialog("You don't have enough coins for a gun.");
      }
    }

    function checkCollision(a, b) {
      return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
    }

    function checkCircleRectCollision(circle, rect) {
      // Find the closest point to the circle within the rectangle
      const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
      const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));

      // Calculate the distance between the circle's center and this closest point
      const distanceX = circle.x - closestX;
      const distanceY = circle.y - closestY;

      // If the distance is less than the circle's radius, an intersection occurs
      const distanceSquared = distanceX * distanceX + distanceY * distanceY;
      return distanceSquared < circle.radius * circle.radius;
    }

    function checkCircleCollision(c1, c2) {
      const dx = c1.x - c2.x;
      const dy = c1.y - c2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < c1.radius + c2.radius;
    }

    function startNewGame() {
      // Reset game state
      gameState = "loading";
      player.health = player.maxHealth;
      player.coins = 0;
      player.hasGun = false;
      player.x = 100;
      player.y = 300;
      speedrunTime = 0;
      finalTime = 0;
      currentLevelIndex = 0;
      secretCar.found = false;

      // Show loading screen
      showLoadingScreen("Loading Old Kingdom...");

      // Load first level with delay to show loading screen
      setTimeout(() => {
        loadLevel(0);
        hideLoadingScreen();
        gameState = "world";
        countryNameDisplayTime = COUNTRY_NAME_DISPLAY_DURATION;
      }, 1500);

      // Clear any existing game data
      clearGameProgress();
    }

    function continueGame() {
      const savedGame = loadGameProgress();
      if (!savedGame) {
        showNotification("No saved game found!");
        return;
      }

      gameState = "loading";

      // Restore player state
      player.health = savedGame.player.health;
      player.coins = savedGame.player.coins;
      player.hasGun = savedGame.player.hasGun;
      player.x = savedGame.player.x;
      player.y = savedGame.player.y;

      // Restore game progress
      currentLevelIndex = savedGame.currentLevel;
      speedrunTime = savedGame.speedrunTime || 0;
      secretCar.found = savedGame.secretCarFound || false;

      // Show loading screen
      showLoadingScreen(`Loading ${levels[currentLevelIndex].name}...`);

      // Load level with delay to show loading screen
      setTimeout(() => {
        loadLevel(currentLevelIndex);
        hideLoadingScreen();

        // Set correct game state based on level
        if (currentLevelIndex === levels.length - 1) {
          gameState = "bossFight";
        } else {
          gameState = "world";
        }

        countryNameDisplayTime = COUNTRY_NAME_DISPLAY_DURATION;
        showNotification("Game Loaded Successfully!");
      }, 1500);
    }

    function loadLevel(levelIndex) {
      if (levelIndex < 0 || levelIndex >= levels.length) {
        console.error("Invalid level index:", levelIndex);
        return;
      }

      currentLevelIndex = levelIndex;
      currentLevel = levels[levelIndex];

      // Reset level-specific collections
      goons = [];
      coins = [];
      bullets = [];
      particles = [];

      // Set up NPCs for this level
      activeNPCs = currentLevel.npcs ? currentLevel.npcs.map((npc) => ({
        ...npc,
        width: 40,
        height: 40,
      })) : [];

      // Reset timers
      goonTimer = 0;
      coinTimer = 0;

      // Position player at the start of the level if not continuing
      if (player.x < 100 || player.x > currentLevel.width - 100) {
        player.x = 100;
        player.y = currentLevel.height / 2;
      }

      // Update camera to focus on player
      camera.x = player.x - camera.width / 2;
      camera.y = player.y - camera.height / 2;

      // Initialize level-specific elements - ALWAYS call init
      if (currentLevel.init) {
        currentLevel.init();
      }

      // Position secret car in the current level
      if (levelIndex === 2) { // Secret car in Frozen Tundra
        secretCar.x = 5800;
        secretCar.y = 800;
      }

      // Save game progress
      saveGameProgress();
    }

    function advanceToNextLevel() {
      if (currentLevelIndex < levels.length - 1) {
        gameState = "loading";
        currentLevelIndex++;

        // Show loading screen
        showLoadingScreen(`Loading ${levels[currentLevelIndex].name}...`);

        // Position player at start of new level
        player.x = 100;
        player.y = levels[currentLevelIndex].height / 2;

        // Load next level with delay to show loading screen
        setTimeout(() => {
          loadLevel(currentLevelIndex);
          hideLoadingScreen();
          gameState = "world";
          countryNameDisplayTime = COUNTRY_NAME_DISPLAY_DURATION;
        }, 1500);
      } else {
        // If this was the last level, enter boss fight
        enterBossFight();
      }
    }

    function enterBossFight() {
      gameState = "loading";

      // Show loading screen
      showLoadingScreen("Entering Castle Dungeon...");

      // Load castle level with delay to show loading screen
      setTimeout(() => {
        // Make sure we're loading the correct boss level
        currentLevelIndex = 3; // Castle is the last level (index 3)

        // Directly load the level to ensure proper initialization
        loadLevel(currentLevelIndex);

        // Ensure boss is properly initialized
        if (currentLevel && currentLevel.boss) {
          // Reset boss health
          currentLevel.boss.hp = currentLevel.boss.maxHp;
          currentLevel.boss.attackProjectiles = [];
          currentLevel.boss.state = "idle";
          currentLevel.boss.lastStateChange = 0;

          // Position player in a good starting position for the boss fight
          player.x = 2000;
          player.y = 2400;

          // Update camera to focus on player
          camera.x = player.x - camera.width / 2;
          camera.y = player.y - camera.height / 2;
          camera.targetX = camera.x;
          camera.targetY = camera.y;

          gameState = "bossFight";
          hideLoadingScreen();
          showNotification("Boss Fight Begins! Find and defeat the boss!");
        } else {
          console.error("Boss not properly initialized!");
          gameState = "world";
          hideLoadingScreen();
          showNotification("Error loading boss fight. Try again.");
        }
      }, 2000);
    }

    function updateGame(deltaTime) {
      if (isPaused) return;

      // Apply performance scaling to ensure consistent game speed
      const scaledDeltaTime = deltaTime * performanceRatio;

      // Update speedrun timer
      if (gameState !== "start" && gameState !== "records" && gameState !== "loading" && gameState !== "settings") {
        speedrunTime += scaledDeltaTime;
      }

      // Update player invulnerability
      if (player.invulnerable) {
        player.invulnerableTimer -= scaledDeltaTime;
        if (player.invulnerableTimer <= 0) {
          player.invulnerable = false;
        }
      }

      // Update player animation
      player.animationTimer += scaledDeltaTime;
      if (player.animationTimer >= player.animationSpeed) {
        player.animationFrame = (player.animationFrame + 1) % 4;
        player.animationTimer = 0;
      }

      // Update based on game state
      switch (gameState) {
        case "world":
        case "combat":
          updateWorldState(scaledDeltaTime);
          break;
        case "bossFight":
          updateBossFightState(scaledDeltaTime);
          break;
      }

      // Update country name display timer
      if (countryNameDisplayTime > 0) {
        countryNameDisplayTime -= scaledDeltaTime;
      }

      // Update particles
      updateParticles(scaledDeltaTime);

      // Check for secret car discovery
      if (currentLevelIndex === 2 && !secretCar.found) {
        const distance = Math.sqrt(
          Math.pow(player.x - secretCar.x, 2) + Math.pow(player.y - secretCar.y, 2)
        );

        if (distance < 100) {
          secretCar.found = true;
          showNotification("You found the secret car!");

          // Create discovery particles
          createParticles(
            secretCar.x + secretCar.width / 2,
            secretCar.y + secretCar.height / 2,
            30,
            "gold",
            1.5,
            2000
          );

          saveGameProgress();
        }
      }
    }

    function updateWorldState(deltaTime) {
      // Player movement
      movePlayer(deltaTime);

      // Update player trail
      updatePlayerTrail();

      // Camera follows player
      camera.follow(player);

      // Spawn and update goons
      updateGoons(deltaTime);

      // Spawn and update coins
      updateCoins(deltaTime);

      // Update bullets
      updateBullets(deltaTime);

      // Check if player reached the end of the level
      if (player.x + player.width >= currentLevel.width) {
        advanceToNextLevel();
      }
    }

    function updateBossFightState(deltaTime) {
      // Player movement with wall collision detection
      movePlayerWithCollision(deltaTime);

      // Update player trail
      updatePlayerTrail();

      // Camera follows player
      camera.follow(player);

      // Update boss behavior
      if (currentLevel && currentLevel.updateBoss) {
        currentLevel.updateBoss(deltaTime);
      }

      // Update bullets
      updateBullets(deltaTime);
    }

    function updatePlayerTrail() {
      // Add current position to trail
      if (player.maxTrailLength > 0 &&
        (keys["ArrowUp"] || keys["ArrowDown"] || keys["ArrowLeft"] || keys["ArrowRight"])) {
        player.trail.push({
          x: player.x + player.width / 2,
          y: player.y + player.height / 2,
          alpha: 0.7
        });

        // Limit trail length
        if (player.trail.length > player.maxTrailLength) {
          player.trail.shift();
        }
      }

      // Fade trail
      for (let i = 0; i < player.trail.length; i++) {
        player.trail[i].alpha -= 0.01;
        if (player.trail[i].alpha <= 0) {
          player.trail.splice(i, 1);
          i--;
        }
      }
    }

    function movePlayer(deltaTime) {
      let newX = player.x;
      let newY = player.y;
      const moveDistance = player.speed * (deltaTime / 1000);

      if (keys["ArrowUp"] && player.y > 0) {
        newY -= moveDistance;
      }
      if (keys["ArrowDown"] && player.y + player.height < currentLevel.height) {
        newY += moveDistance;
      }
      if (keys["ArrowLeft"] && player.x > 0) {
        newX -= moveDistance;
      }
      if (keys["ArrowRight"] && player.x + player.width < currentLevel.width) {
        newX += moveDistance;
      }

      player.x = newX;
      player.y = newY;
    }

    function movePlayerWithCollision(deltaTime) {
      let newX = player.x;
      let newY = player.y;
      const moveDistance = player.speed * (deltaTime / 1000);

      if (keys["ArrowUp"]) newY -= moveDistance;
      if (keys["ArrowDown"]) newY += moveDistance;
      if (keys["ArrowLeft"]) newX -= moveDistance;
      if (keys["ArrowRight"]) newX += moveDistance;

      // Check wall collisions before updating position
      if (!checkWallCollisions(newX, player.y)) {
        player.x = newX;
      }

      if (!checkWallCollisions(player.x, newY)) {
        player.y = newY;
      }
    }

    function checkWallCollisions(newX, newY) {
      if (!currentLevel || !currentLevel.walls) return false;

      const playerRect = {
        x: newX,
        y: newY,
        width: player.width,
        height: player.height,
      };

      for (const wall of currentLevel.walls) {
        if (wall.isRotated) {
          // Skip rotated walls for now (simplified collision)
          continue;
        }

        if (checkCollision(playerRect, wall)) {
          return true;
        }
      }

      return false;
    }

    function updateGoons(deltaTime) {
      if (!currentLevel) return;

      // Spawn new goons
      goonTimer += deltaTime;
      if (goonTimer > 2000 / currentLevel.goonDensity) {
        const size = Math.random() * 30 + 20;
        const spawnY = Math.random() * (currentLevel.height - size);

        // Randomly choose spawn side (left or right)
        const spawnSide = Math.random() > 0.5 ? "left" : "right";
        const spawnX = spawnSide === "left" ? -size : currentLevel.width;

        goons.push({
          x: spawnX,
          y: spawnY,
          width: size,
          height: size,
          speed: 30 + Math.random() * 60, // pixels per second
          health: 3,
          damage: 2,
          attackCooldown: 0,
          attackRate: 1000,
          color: "black",
          direction: spawnSide === "left" ? 1 : -1,
          // Animation
          animationFrame: Math.floor(Math.random() * 4),
          animationTimer: 0,
          animationSpeed: 200 + Math.random() * 100,
        });

        goonTimer = 0;
      }

      // Update existing goons
      for (let i = goons.length - 1; i >= 0; i--) {
        const goon = goons[i];

        // Skip updating if not visible (optimization)
        if (!camera.isVisible(goon)) {
          continue;
        }

        // Update animation
        goon.animationTimer += deltaTime;
        if (goon.animationTimer >= goon.animationSpeed) {
          goon.animationFrame = (goon.animationFrame + 1) % 4;
          goon.animationTimer = 0;
        }

        // Calculate direction to player
        const dx = player.x - goon.x;
        const dy = player.y - goon.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Move toward player
        if (distance > 50) {
          // Don't get too close
          const moveDistance = goon.speed * (deltaTime / 1000);
          goon.x += (dx / distance) * moveDistance;
          goon.y += (dy / distance) * moveDistance;
        }

        // Attack player if close enough and cooldown is ready
        goon.attackCooldown -= deltaTime;
        if (distance < 60 && goon.attackCooldown <= 0) {
          if (!player.invulnerable && !godMode) {
            player.health -= goon.damage;
            player.invulnerable = true;
            player.invulnerableTimer = player.invulnerableDuration;

            // Create hit particles
            createParticles(
              player.x + player.width / 2,
              player.y + player.height / 2,
              10,
              "red",
              0.8,
              500
            );

            // Game over if player health reaches 0
            if (player.health <= 0) {
              gameState = "over";
              document.getElementById("restartBtn").style.display = "inline-block";
            }
          }
          goon.attackCooldown = goon.attackRate;
        }

        // Check if goon is hit by bullets
        for (let j = bullets.length - 1; j >= 0; j--) {
          const bullet = bullets[j];
          if (bullet.fromPlayer && checkCircleRectCollision(bullet, goon)) {
            goon.health -= bullet.damage;
            bullets.splice(j, 1);

            // Create hit particles
            createParticles(
              bullet.x,
              bullet.y,
              5,
              "orange",
              0.5,
              300
            );

            if (goon.health <= 0) {
              // Create death particles
              createParticles(
                goon.x + goon.width / 2,
                goon.y + goon.height / 2,
                15,
                "black",
                1,
                800
              );

              // Drop a coin when goon dies (50% chance)
              if (Math.random() > 0.5) {
                coins.push({
                  x: goon.x + goon.width / 2 - 10,
                  y: goon.y + goon.height / 2 - 10,
                  width: 20,
                  height: 20,
                  color: "gold",
                  // Animation
                  animationFrame: 0,
                  animationTimer: 0,
                  animationSpeed: 150,
                });
              }
              goons.splice(i, 1);
              break;
            }
          }
        }

        // Remove goons that go off-screen
        if (goon.x < -100 || goon.x > currentLevel.width + 100 || goon.y < -100 || goon.y > currentLevel.height + 100) {
          goons.splice(i, 1);
        }
      }
    }

    function updateCoins(deltaTime) {
      if (!currentLevel) return;

      // Spawn new coins
      coinTimer += deltaTime;
      if (coinTimer > 5000) {
        coins.push({
          x: Math.random() * (currentLevel.width - 20),
          y: Math.random() * (currentLevel.height - 20),
          width: 20,
          height: 20,
          color: "gold",
          // Animation
          animationFrame: 0,
          animationTimer: 0,
          animationSpeed: 150,
        });
        coinTimer = 0;
      }

      // Update coin animations
      for (const coin of coins) {
        coin.animationTimer += deltaTime;
        if (coin.animationTimer >= coin.animationSpeed) {
          coin.animationFrame = (coin.animationFrame + 1) % 8;
          coin.animationTimer = 0;
        }
      }

      // Check coin collection
      for (let i = coins.length - 1; i >= 0; i--) {
        if (checkCollision(player, coins[i])) {
          player.coins += 1;

          // Create collection particles
          createParticles(
            coins[i].x + coins[i].width / 2,
            coins[i].y + coins[i].height / 2,
            10,
            "gold",
            0.8,
            500
          );

          coins.splice(i, 1);
          saveGameProgress();
        }
      }
    }

    function updateBullets(deltaTime) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];

        // Update bullet position
        const moveDistance = bullet.speed * (deltaTime / 1000);
        bullet.x += bullet.direction.x * moveDistance;
        bullet.y += bullet.direction.y * moveDistance;

        // Update bullet lifetime
        bullet.timeLeft -= deltaTime;
        if (bullet.timeLeft <= 0) {
          bullets.splice(i, 1);
          continue;
        }

        // Check wall collisions
        if (currentLevel && currentLevel.walls) {
          let hitWall = false;

          for (const wall of currentLevel.walls) {
            if (wall.isRotated) {
              // Skip rotated walls for simplified collision
              continue;
            }

            if (checkCircleRectCollision(bullet, wall)) {
              hitWall = true;
              break;
            }
          }

          if (hitWall) {
            // Create wall hit particles
            createParticles(
              bullet.x,
              bullet.y,
              8,
              "gray",
              0.5,
              300
            );

            bullets.splice(i, 1);
            continue;
          }
        }

        // Check if bullet is out of bounds
        if (!currentLevel || bullet.x < 0 || bullet.x > currentLevel.width || bullet.y < 0 || bullet.y > currentLevel.height) {
          bullets.splice(i, 1);
        }
      }
    }

    function createParticles(x, y, count, color, size = 1, lifetime = 1000) {
      // Skip particles on low graphics setting
      if (graphicsQuality === "low") return;

      // Limit particle count based on graphics quality
      const actualCount = graphicsQuality === "high" ? count : Math.ceil(count / 2);

      for (let i = 0; i < actualCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 50 + Math.random() * 100;
        const particleSize = (Math.random() * 3 + 2) * size;

        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: particleSize,
          color,
          alpha: 1,
          lifetime,
          timeLeft: lifetime,
        });
      }
    }

    function updateParticles(deltaTime) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];

        // Update position
        particle.x += particle.vx * (deltaTime / 1000);
        particle.y += particle.vy * (deltaTime / 1000);

        // Apply gravity
        particle.vy += 50 * (deltaTime / 1000);

        // Update lifetime and alpha
        particle.timeLeft -= deltaTime;
        particle.alpha = particle.timeLeft / particle.lifetime;

        // Remove dead particles
        if (particle.timeLeft <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function gameLoop(timestamp) {
      // Calculate delta time
      if (!lastTime) lastTime = timestamp;
      deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      // Cap delta time to prevent huge jumps after tab switch
      if (deltaTime > 100) deltaTime = 100;

      // Calculate FPS
      if (showFpsCounter || showPerformanceIndicator) {
        fpsArray.push(1000 / deltaTime);
        if (fpsArray.length > 60) {
          fpsArray.shift();
        }

        // Update FPS counter every 10 frames
        if (timestamp % 10 < 1) {
          const avgFps = Math.round(
            fpsArray.reduce((sum, fps) => sum + fps, 0) / fpsArray.length
          );

          if (showFpsCounter) {
            document.getElementById("fpsCounter").textContent = `FPS: ${avgFps}`;
          }

          currentFps = avgFps;
        }
      }

      // Update performance ratio periodically
      if (timestamp - lastPerformanceUpdate > PERFORMANCE_UPDATE_INTERVAL) {
        // Calculate performance ratio based on current FPS vs target FPS
        // This helps maintain consistent game speed across different hardware
        performanceRatio = TARGET_FPS / Math.max(currentFps, 1);

        // Clamp performance ratio to reasonable bounds
        performanceRatio = Math.max(0.5, Math.min(performanceRatio, 2.0));

        // Update performance indicator
        if (showPerformanceIndicator) {
          const performancePercent = Math.round((1 / performanceRatio) * 100);
          document.getElementById("performanceIndicator").textContent = `Performance: ${performancePercent}%`;
        }

        lastPerformanceUpdate = timestamp;
      }

      // Fixed time step for physics
      accumulator += deltaTime;

      while (accumulator >= FRAME_TIME) {
        if (gameState !== "records" && gameState !== "settings") {
          updateGame(FRAME_TIME);
        }
        accumulator -= FRAME_TIME;
      }

      // Render at full frame rate
      renderGame();

      requestAnimationFrame(gameLoop);
    }

    // ===== STORAGE SYSTEM =====

    function saveGameProgress(additionalData = {}) {
      const gameData = {
        player: {
          health: player.health,
          coins: player.coins,
          hasGun: player.hasGun,
          x: player.x,
          y: player.y,
        },
        currentLevel: currentLevelIndex,
        speedrunTime: speedrunTime,
        lastSaved: new Date().toISOString(),
        secretCarFound: secretCar.found,
        ...additionalData,
      };

      localStorage.setItem("goonerbaitSave", JSON.stringify(gameData));
    }

    function loadGameProgress() {
      const savedData = localStorage.getItem("goonerbaitSave");
      return savedData ? JSON.parse(savedData) : null;
    }

    function clearGameProgress() {
      localStorage.removeItem("goonerbaitSave");
    }

    function saveSpeedrunRecord(playerName, time) {
      let records = JSON.parse(localStorage.getItem("speedrunRecords")) || [];

      const newRecord = {
        name: playerName,
        time: time,
        date: new Date().toISOString(),
      };

      records.push(newRecord);

      // Sort records by time (ascending)
      records.sort((a, b) => a.time - b.time);

      // Keep only top 10 records
      if (records.length > 10) {
        records = records.slice(0, 10);
      }

      localStorage.setItem("speedrunRecords", JSON.stringify(records));
      return records;
    }

    function getSpeedrunRecords() {
      return JSON.parse(localStorage.getItem("speedrunRecords")) || [];
    }

    function formatTime(timeMs) {
      const totalSeconds = timeMs / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const milliseconds = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 100);

      return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}.${milliseconds.toString().padStart(2, "0")}`;
    }

    // ===== UI SYSTEM =====

    // UI Elements
    const dialogBox = document.getElementById("dialogBox");
    const recordBoard = document.getElementById("recordBoard");
    const recordList = document.getElementById("recordList");
    const playerNameInput = document.getElementById("playerName");
    const submitRecordBtn = document.getElementById("submitRecordBtn");
    const closeRecordBtn = document.getElementById("closeRecordBtn");
    const viewRecordsBtn = document.getElementById("viewRecordsBtn");
    const restartBtn = document.getElementById("restartBtn");
    const continueBtn = document.getElementById("continueBtn");
    const settingsBtn = document.getElementById("settingsBtn");
    const loadingScreen = document.getElementById("loadingScreen");
    const progressFill = document.querySelector(".progress-fill");
    const devPanel = document.getElementById("devPanel");
    const settingsPanel = document.getElementById("settingsPanel");
    const closeSettingsBtn = document.getElementById("closeSettingsBtn");
    const fpsCounter = document.getElementById("fpsCounter");
    const performanceIndicator = document.getElementById("performanceIndicator");

    // Dialog management
    let currentDialog = "";

    // Event listeners
    restartBtn.addEventListener("click", restartGame);
    submitRecordBtn.addEventListener("click", submitRecord);
    closeRecordBtn.addEventListener("click", closeRecordBoard);
    viewRecordsBtn.addEventListener("click", showRecordBoard);
    continueBtn.addEventListener("click", continueGame);
    settingsBtn.addEventListener("click", toggleSettings);
    closeSettingsBtn.addEventListener("click", closeSettings);

    // Developer mode buttons
    document.getElementById("devLevelOldKingdom").addEventListener("click", () => loadDevLevel(0));
    document.getElementById("devLevelDesert").addEventListener("click", () => loadDevLevel(1));
    document.getElementById("devLevelTundra").addEventListener("click", () => loadDevLevel(2));
    document.getElementById("devLevelCastle").addEventListener("click", () => loadDevLevel(3));
    document.getElementById("devGodMode").addEventListener("click", toggleGodMode);
    document.getElementById("devAddCoins").addEventListener("click", () => { player.coins += 10; saveGameProgress(); });
    document.getElementById("devGiveGun").addEventListener("click", () => { player.hasGun = true; saveGameProgress(); });
    document.getElementById("devShowInfo").addEventListener("click", () => { showDebugInfo = !showDebugInfo; });
    document.getElementById("devClose").addEventListener("click", () => { devPanel.style.display = "none"; });

    function loadDevLevel(levelIndex) {
      if (levelIndex === 3) {
        // Special handling for boss level
        gameState = "loading";
        showLoadingScreen("Loading Castle Dungeon...");

        // Clear any saved progress for the boss level to ensure fresh initialization
        const savedGame = loadGameProgress();
        if (savedGame) {
          savedGame.currentLevel = 3;
          localStorage.setItem("goonerbaitSave", JSON.stringify(savedGame));
        }

        setTimeout(() => {
          // Directly load the boss level
          currentLevelIndex = 3;
          loadLevel(3);

          // Ensure boss is properly initialized
          if (currentLevel && currentLevel.boss) {
            // Reset boss health
            currentLevel.boss.hp = currentLevel.boss.maxHp;
            currentLevel.boss.attackProjectiles = [];
            currentLevel.boss.state = "idle";
            currentLevel.boss.lastStateChange = 0;

            // Position player in a good starting position for the boss fight
            player.x = 2000;
            player.y = 2400;

            // Update camera to focus on player immediately without easing
            camera.x = player.x - camera.width / 2;
            camera.y = player.y - camera.height / 2;
            camera.targetX = camera.x;
            camera.targetY = camera.y;

            gameState = "bossFight";
            hideLoadingScreen();
            showNotification("Boss Fight Begins! Find and defeat the boss!");
          } else {
            console.error("Boss not properly initialized!");
            gameState = "world";
            hideLoadingScreen();
            showNotification("Error loading boss fight. Try again.");
          }
        }, 1000);
      } else {
        gameState = "loading";
        showLoadingScreen(`Loading ${levels[levelIndex].name}...`);

        setTimeout(() => {
          loadLevel(levelIndex);
          hideLoadingScreen();
          gameState = "world";
          countryNameDisplayTime = COUNTRY_NAME_DISPLAY_DURATION;
        }, 1000);
      }
    }

    function toggleGodMode() {
      godMode = !godMode;
      if (godMode) {
        player.health = player.maxHealth;
        showNotification("God Mode Enabled");
      } else {
        showNotification("God Mode Disabled");
      }
    }

    function restartGame() {
      startNewGame();
      document.getElementById("restartBtn").style.display = "none";
      document.getElementById("viewRecordsBtn").style.display = "none";
    }

    function showDialog(text) {
      dialogBox.innerText = text;
      dialogBox.style.display = "block";
      dialogActive = true;
      gameState = "talk";
    }

    function hideDialog() {
      dialogBox.style.display = "none";
      dialogActive = false;
    }

    function showRecordBoard() {
      gameState = "records";
      updateRecordList();
      recordBoard.style.display = "block";
    }

    function closeRecordBoard() {
      recordBoard.style.display = "none";
      if (finalTime > 0) {
        gameState = "win";
      } else {
        gameState = "start";
      }
    }

    function submitRecord() {
      const playerName = playerNameInput.value.trim();
      if (!playerName) {
        alert("Please enter your name!");
        return;
      }

      const records = saveSpeedrunRecord(playerName, finalTime);
      updateRecordList(records);
      playerNameInput.value = "";

      showNotification("Record submitted successfully!");
    }

    function updateRecordList(records = null) {
      // Get records if not provided
      if (!records) {
        records = getSpeedrunRecords();
      }

      // Clear the current list
      recordList.innerHTML = "";

      // Add each record to the list
      records.forEach((record, index) => {
        const li = document.createElement("li");

        const nameSpan = document.createElement("span");
        nameSpan.className = "record-name";
        nameSpan.textContent = `${index + 1}. ${record.name}`;

        const timeSpan = document.createElement("span");
        timeSpan.className = "record-time";
        timeSpan.textContent = formatTime(record.time);

        li.appendChild(nameSpan);
        li.appendChild(timeSpan);
        recordList.appendChild(li);
      });

      // Show a message if no records
      if (records.length === 0) {
        const li = document.createElement("li");
        li.textContent = "No records yet. Be the first!";
        recordList.appendChild(li);
      }
    }

    function showLoadingScreen(message = "Loading...") {
      loadingScreen.querySelector("h2").textContent = message;
      loadingScreen.style.display = "flex";
      progressFill.style.width = "0%";

      // Animate progress bar
      let progress = 0;
      const interval = setInterval(() => {
        progress += 1;
        progressFill.style.width = `${progress}%`;

        if (progress >= 100) {
          clearInterval(interval);
        }
      }, 15);
    }

    function hideLoadingScreen() {
      loadingScreen.style.display = "none";
    }

    function showNotification(message) {
      // Create notification element if it doesn't exist
      let notification = document.querySelector(".notification");
      if (!notification) {
        notification = document.createElement("div");
        notification.className = "notification";
        document.body.appendChild(notification);
      }

      // Set message and show notification
      notification.textContent = message;
      notification.classList.add("show");

      // Hide notification after 3 seconds
      setTimeout(() => {
        notification.classList.remove("show");
      }, 3000);
    }

    function renderGame() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Handle different game states
      switch (gameState) {
        case "start":
          renderStartScreen();
          break;
        case "world":
        case "combat":
        case "talk":
        case "bossFight":
          renderGameWorld();
          break;
        case "win":
          renderWinScreen();
          break;
        case "over":
          renderGameOverScreen();
          break;
        case "settings":
          // Settings are handled by HTML, just render a dimmed background
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          break;
      }
    }

    function renderStartScreen() {
      // Background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, "#000033");
      gradient.addColorStop(1, "#000066");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      ctx.fillStyle = "white";
      for (let i = 0; i < 200; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 2 + 1;
        ctx.fillRect(x, y, size, size);
      }

      // Animated stars (twinkle effect)
      for (let i = 0; i < 50; i++) {
        const x = Math.sin(Date.now() / 1000 + i) * canvas.width / 2 + canvas.width / 2;
        const y = Math.cos(Date.now() / 1000 + i * 2) * canvas.height / 2 + canvas.height / 2;
        const size = (Math.sin(Date.now() / 500 + i) + 1.5) * 2;

        ctx.fillStyle = `rgba(255, 255, 255, ${0.7 + Math.sin(Date.now() / 300 + i) * 0.3})`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }

      // Title
      ctx.fillStyle = "white";
      ctx.font = "50px monospace";
      ctx.textAlign = "center";
      ctx.fillText("GOONERBAIT 3D Adventure", canvas.width / 2, canvas.height / 3);

      // Title shadow
      ctx.fillStyle = "rgba(0, 100, 255, 0.5)";
      ctx.fillText("GOONERBAIT 3D Adventure", canvas.width / 2 + 2, canvas.height / 3 + 2);

      // Subtitle
      ctx.font = "30px sans-serif";
      ctx.fillStyle = "white";
      ctx.fillText("Press RIGHT ARROW to start your journey", canvas.width / 2, canvas.height / 2);

      // Animated arrow
      const arrowX = canvas.width / 2 + 200 + Math.sin(Date.now() / 300) * 10;
      ctx.beginPath();
      ctx.moveTo(arrowX, canvas.height / 2);
      ctx.lineTo(arrowX + 20, canvas.height / 2 - 10);
      ctx.lineTo(arrowX + 20, canvas.height / 2 + 10);
      ctx.closePath();
      ctx.fill();

      // Version
      ctx.font = "16px sans-serif";
      ctx.fillText("Enhanced Edition v2.3", canvas.width / 2, canvas.height / 2 + 40);

      // Controls info
      ctx.font = "18px sans-serif";
      ctx.fillText("Controls: Arrow Keys to move, E to interact, S to shoot, A to swing sword", canvas.width / 2, canvas.height - 100);
      ctx.fillText("P to pause, O for settings, SPACE to attack boss, D for developer mode", canvas.width / 2, canvas.height - 70);

      // Continue button visibility
      continueBtn.style.display = loadGameProgress() && !loadGameProgress().completed ? "inline-block" : "none";
      settingsBtn.style.display = "inline-block";
    }

    function renderGameWorld() {
      // Save canvas state before applying camera transform
      ctx.save();

      // Apply camera transform
      ctx.translate(-camera.x, -camera.y);

      // Render level background - always render regardless of visibility
      if (currentLevel && currentLevel.renderBackground) {
        currentLevel.renderBackground(ctx);
      }

      // Render level-specific elements - always render regardless of visibility
      if (currentLevel && currentLevel.render) {
        currentLevel.render(ctx);
      }

      // Render player trail
      renderPlayerTrail();

      // Render game objects
      renderCoins();
      renderGoons();
      renderNPCs();
      renderBullets();
      renderPlayer();
      renderParticles();

      // Render secret car if found
      if (secretCar.found && currentLevelIndex === 2) {
        secretCar.render(ctx);
      }

      // Render boss if in boss fight
      if (gameState === "bossFight" && currentLevel && currentLevel.renderBoss) {
        currentLevel.renderBoss(ctx);
      }

      // Restore canvas state
      ctx.restore();

      // Render UI elements (not affected by camera)
      renderUI();

      // Render minimap if in boss fight
      if (gameState === "bossFight" && currentLevel && currentLevel.renderMinimap) {
        currentLevel.renderMinimap(ctx);
      }

      // Render pause overlay
      if (isPaused) {
        renderPauseOverlay();
      }

      // Render debug info if enabled
      if (showDebugInfo) {
        renderDebugInfo();
      }
    }

    function renderPlayerTrail() {
      for (let i = 0; i < player.trail.length; i++) {
        const trail = player.trail[i];
        ctx.fillStyle = `rgba(255, 100, 100, ${trail.alpha})`;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, player.width / 3 * (i / player.trail.length), 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function renderParticles() {
      for (const particle of particles) {
        ctx.fillStyle = `rgba(${hexToRgb(particle.color)}, ${particle.alpha})`;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function hexToRgb(hex) {
      // Default colors if hex is a named color
      const namedColors = {
        "red": "255, 0, 0",
        "green": "0, 255, 0",
        "blue": "0, 0, 255",
        "yellow": "255, 255, 0",
        "orange": "255, 165, 0",
        "purple": "128, 0, 128",
        "black": "0, 0, 0",
        "white": "255, 255, 255",
        "gray": "128, 128, 128",
        "gold": "255, 215, 0"
      };

      if (namedColors[hex]) {
        return namedColors[hex];
      }

      // Otherwise parse hex
      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ?
        parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) :
        "255, 255, 255";
    }

    function renderDebugInfo() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(10, 110, 300, 220);

      ctx.fillStyle = "#00ff00";
      ctx.font = "14px monospace";
      ctx.textAlign = "left";

      const debugInfo = [
        `FPS: ${currentFps}`,
        `Performance Ratio: ${performanceRatio.toFixed(2)}`,
        `Player: (${Math.round(player.x)}, ${Math.round(player.y)})`,
        `Level: ${currentLevelIndex} - ${currentLevel ? currentLevel.name : "Unknown"}`,
        `Game State: ${gameState}`,
        `Goons: ${goons.length}`,
        `Bullets: ${bullets.length}`,
        `Coins: ${coins.length}`,
        `Particles: ${particles.length}`,
        `God Mode: ${godMode ? "ON" : "OFF"}`,
        `Secret Car: ${secretCar.found ? "Found" : "Hidden"}`,
        `Graphics: ${graphicsQuality}`,
        `Delta Time: ${Math.round(deltaTime)}ms`
      ];

      debugInfo.forEach((info, index) => {
        ctx.fillText(info, 20, 130 + index * 16);
      });
    }

    function renderPauseOverlay() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "white";
      ctx.font = "40px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2);
      ctx.font = "20px sans-serif";
      ctx.fillText("Press P to resume", canvas.width / 2, canvas.height / 2 + 40);
      ctx.textAlign = "left";
    }

    function renderCoins() {
      coins.forEach((coin) => {
        // Skip rendering if not visible (optimization)
        if (!camera.isVisible(coin)) return;

        // Coin body
        ctx.fillStyle = coin.color;
        ctx.beginPath();

        // Animated coin (rotating effect)
        const wobble = Math.sin(Date.now() / 200 + coin.x * 0.1) * 2;
        const width = coin.width - Math.abs(wobble);

        ctx.ellipse(
          coin.x + coin.width / 2,
          coin.y + coin.height / 2,
          width / 2,
          coin.height / 2,
          0, 0, Math.PI * 2
        );
        ctx.fill();

        // Coin border
        ctx.strokeStyle = "#B8860B";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Coin shine
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        ctx.beginPath();
        ctx.arc(coin.x + coin.width / 3, coin.y + coin.height / 3, coin.width / 6, 0, Math.PI * 2);
        ctx.fill();

        // Coin dollar sign
        ctx.fillStyle = "#B8860B";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("$", coin.x + coin.width / 2, coin.y + coin.height / 2);
        ctx.textAlign = "left";
        ctx.textBaseline = "alphabetic";
      });
    }

    function renderGoons() {
      goons.forEach((goon) => {
        // Skip rendering if not visible (optimization)
        if (!camera.isVisible(goon)) return;

        // Goon body
        ctx.fillStyle = goon.color;
        ctx.fillRect(goon.x, goon.y, goon.width, goon.height);

        // Goon eyes
        ctx.fillStyle = "red";
        const eyeSize = goon.width / 5;

        // Animated eyes (blinking)
        if (goon.animationFrame !== 3) {
          ctx.fillRect(goon.x + goon.width / 4 - eyeSize / 2, goon.y + goon.height / 3, eyeSize, eyeSize);
          ctx.fillRect(goon.x + (goon.width * 3) / 4 - eyeSize / 2, goon.y + goon.height / 3, eyeSize, eyeSize);
        } else {
          // Blinking
          ctx.fillRect(goon.x + goon.width / 4 - eyeSize / 2, goon.y + goon.height / 3, eyeSize, eyeSize / 4);
          ctx.fillRect(goon.x + (goon.width * 3) / 4 - eyeSize / 2, goon.y + goon.height / 3, eyeSize, eyeSize / 4);
        }

        // Goon mouth
        ctx.fillStyle = "white";

        // Animated mouth
        const mouthHeight = goon.height / 10 * (1 + Math.sin(goon.animationFrame / 2) * 0.5);
        ctx.fillRect(goon.x + goon.width / 4, goon.y + (goon.height * 2) / 3, goon.width / 2, mouthHeight);

        // Goon health bar
        const healthPercent = goon.health / 3; // Assuming max health is 3
        ctx.fillStyle = "black";
        ctx.fillRect(goon.x, goon.y - 10, goon.width, 5);
        ctx.fillStyle = healthPercent > 0.5 ? "green" : "red";
        ctx.fillRect(goon.x, goon.y - 10, goon.width * healthPercent, 5);
      });
    }

    function renderNPCs() {
      activeNPCs.forEach((npc) => {
        // Skip rendering if not visible (optimization)
        if (!camera.isVisible(npc)) return;

        // Shack base
        ctx.fillStyle = npc.type === "shop" ? "#8B4513" : "#654321";
        ctx.fillRect(npc.x, npc.y, npc.width, npc.height);

        // Shack roof
        ctx.fillStyle = npc.type === "shop" ? "#A52A2A" : "#800000";
        ctx.beginPath();
        ctx.moveTo(npc.x - 5, npc.y);
        ctx.lineTo(npc.x + npc.width / 2, npc.y - 15);
        ctx.lineTo(npc.x + npc.width + 5, npc.y);
        ctx.closePath();
        ctx.fill();

        // Door
        ctx.fillStyle = "#4B3621";
        ctx.fillRect(npc.x + npc.width / 2 - 5, npc.y + npc.height - 15, 10, 15);

        // Window
        if (npc.type === "shop") {
          ctx.fillStyle = "#87CEEB";
          ctx.fillRect(npc.x + 5, npc.y + 5, 10, 10);

          // Window frame
          ctx.strokeStyle = "#4B3621";
          ctx.lineWidth = 1;
          ctx.strokeRect(npc.x + 5, npc.y + 5, 10, 10);
        }

        // Sign
        ctx.fillStyle = "#FAEBD7";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(npc.type, npc.x + npc.width / 2, npc.y - 25);
        ctx.textAlign = "left";
        ctx.textBaseline = "alphabetic";

        // Interaction hint
        if (checkCollision(player, npc)) {
          // Animated hint
          const bounceOffset = Math.sin(Date.now() / 300) * 3;

          ctx.fillStyle = "white";
          ctx.font = "12px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Press E to interact", npc.x + npc.width / 2, npc.y - 40 + bounceOffset);
          ctx.textAlign = "left";
          ctx.textBaseline = "alphabetic";
        }
      });
    }

    function renderBullets() {
      bullets.forEach((bullet) => {
        ctx.fillStyle = bullet.color;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
        ctx.fill();

        // Bullet trail
        ctx.fillStyle = "rgba(255, 165, 0, 0.5)";
        ctx.beginPath();
        ctx.arc(bullet.x - bullet.direction.x * 5, bullet.y - bullet.direction.y * 5, bullet.radius * 0.7, 0, Math.PI * 2);
        ctx.fill();

        // Additional trail for high quality
        if (graphicsQuality === "high") {
          ctx.fillStyle = "rgba(255, 165, 0, 0.3)";
          ctx.beginPath();
          ctx.arc(bullet.x - bullet.direction.x * 10, bullet.y - bullet.direction.y * 10, bullet.radius * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }

    function renderPlayer() {
      // Don't render if invulnerable and should be flashing
      if (player.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
      } else {
        ctx.fillStyle = player.color;
      }

      // Player body
      ctx.fillRect(player.x, player.y, player.width, player.height);

      // Player eyes
      ctx.fillStyle = "white";
      const eyeSize = player.width / 5;

      // Animated eyes (blinking)
      if (player.animationFrame !== 3) {
        ctx.fillRect(player.x + player.width / 4, player.y + player.height / 3, eyeSize, eyeSize);
        ctx.fillRect(player.x + (player.width * 3) / 4 - eyeSize, player.y + player.height / 3, eyeSize, eyeSize);
      } else {
        // Blinking
        ctx.fillRect(player.x + player.width / 4, player.y + player.height / 3, eyeSize, eyeSize / 4);
        ctx.fillRect(player.x + (player.width * 3) / 4 - eyeSize, player.y + player.height / 3, eyeSize, eyeSize / 4);
      }

      // Player weapon
      if (player.hasGun) {
        // Get direction for weapon orientation
        const direction = getPlayerDirection();

        // Gun base
        ctx.fillStyle = "black";

        // Rotate and position gun based on direction
        ctx.save();
        ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
        ctx.rotate(Math.atan2(direction.y, direction.x));

        // Draw gun
        ctx.fillRect(0, -2, 15, 4);

        // Gun details
        ctx.fillStyle = "#555";
        ctx.fillRect(0, -4, 5, 8);

        ctx.restore();
      } else {
        // Sword
        ctx.fillStyle = "silver";
        ctx.fillRect(player.x + player.width, player.y + player.height / 2 - 5, 15, 2);

        // Sword handle
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(player.x + player.width, player.y + player.height / 2 - 7, 5, 6);
      }

      // God mode indicator
      if (godMode) {
        ctx.strokeStyle = "gold";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x + player.width / 2, player.y + player.height / 2, player.width * 0.8, 0, Math.PI * 2);
        ctx.stroke();

        // Halo
        ctx.fillStyle = "rgba(255, 215, 0, 0.3)";
        ctx.beginPath();
        ctx.arc(player.x + player.width / 2, player.y - 5, player.width / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function renderUI() {
      // Background for UI
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, canvas.width, 100);

      // Player stats
      ctx.fillStyle = "white";
      ctx.font = "18px sans-serif";
      ctx.fillText(`Coins: ${player.coins}`, 20, 30);
      ctx.fillText(`Weapon: ${player.hasGun ? "Gun & Sword" : "Sword"}`, 20, 60);

      // Speedrun timer
      ctx.textAlign = "center";
      ctx.fillText(`Time: ${formatTime(speedrunTime)}`, canvas.width / 2, 30);
      ctx.textAlign = "left";

      // Current level name
      ctx.textAlign = "right";
      ctx.fillText(`Level: ${currentLevel ? currentLevel.name : ""}`, canvas.width - 20, 30);
      ctx.textAlign = "left";

      // Player health bar
      ctx.fillStyle = "black";
      ctx.fillRect(20, 75, 200, 15);

      // Health bar color based on health percentage
      const healthPercent = player.health / player.maxHealth;
      if (healthPercent > 0.6) {
        ctx.fillStyle = "green";
      } else if (healthPercent > 0.3) {
        ctx.fillStyle = "yellow";
      } else {
        ctx.fillStyle = "red";
      }

      ctx.fillRect(22, 77, 196 * healthPercent, 11);
      ctx.fillStyle = "white";
      ctx.font = "12px sans-serif";
      ctx.fillText(`Health: ${player.health}/${player.maxHealth}`, 25, 87);

      // Boss health bar (if in boss fight)
      if (gameState === "bossFight" && currentLevel && currentLevel.boss) {
        ctx.fillStyle = "black";
        ctx.fillRect(canvas.width / 2 - 100, 60, 200, 15);

        const bossHealthPercent = currentLevel.boss.hp / currentLevel.boss.maxHp;
        ctx.fillStyle = bossHealthPercent > 0.5 ? "purple" : "red";
        ctx.fillRect(canvas.width / 2 - 98, 62, 196 * bossHealthPercent, 11);

        ctx.fillStyle = "white";
        ctx.font = "12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`Boss: ${currentLevel.boss.hp}/${currentLevel.boss.maxHp}`, canvas.width / 2, 72);
        ctx.textAlign = "left";
      }

      // Country name animation
      if (countryNameDisplayTime > 0 && currentLevel) {
        ctx.fillStyle = `rgba(255, 255, 255, ${countryNameDisplayTime / COUNTRY_NAME_DISPLAY_DURATION})`;
        ctx.font = "40px serif";
        ctx.textAlign = "center";
        ctx.fillText(currentLevel.name, canvas.width / 2, 150);
        ctx.textAlign = "left";
      }

      // Developer mode indicator
      if (isDevMode) {
        ctx.fillStyle = "#00ff00";
        ctx.font = "14px monospace";
        ctx.fillText("DEV MODE", canvas.width - 100, 60);
      }

      // Settings button visibility
      settingsBtn.style.display = "inline-block";
    }

    function renderWinScreen() {
      // Background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, "#000066");
      gradient.addColorStop(1, "#660066");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      ctx.fillStyle = "white";
      for (let i = 0; i < 200; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 2 + 1;
        ctx.fillRect(x, y, size, size);
      }

      // Victory text
      ctx.fillStyle = "gold";
      ctx.font = "60px monospace";
      ctx.textAlign = "center";
      ctx.fillText("VICTORY!", canvas.width / 2, canvas.height / 3);

      // Animated glow
      const glowSize = 10 + Math.sin(Date.now() / 300) * 5;
      ctx.shadowColor = "gold";
      ctx.shadowBlur = glowSize;
      ctx.fillText("VICTORY!", canvas.width / 2, canvas.height / 3);
      ctx.shadowBlur = 0;

      // Completion time
      ctx.fillStyle = "white";
      ctx.font = "30px sans-serif";
      ctx.fillText(`You completed the game in ${formatTime(finalTime)}`, canvas.width / 2, canvas.height / 2);

      // Secret car status
      if (secretCar.found) {
        ctx.fillStyle = "lightblue";
        ctx.font = "24px sans-serif";
        ctx.fillText("You found the secret car!", canvas.width / 2, canvas.height / 2 + 40);

        // Draw the car
        const carX = canvas.width / 2 - 30;
        const carY = canvas.height / 2 + 60;

        // Car body
        ctx.fillStyle = "blue";
        ctx.fillRect(carX, carY, 60, 30);

        // Car windows
        ctx.fillStyle = "lightblue";
        ctx.fillRect(carX + 10, carY - 10, 20, 10);

        // Car wheels
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(carX + 15, carY + 30, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(carX + 45, carY + 30, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      // Instructions
      ctx.fillStyle = "white";
      ctx.font = "20px sans-serif";
      ctx.fillText("Click 'View Records' to see the leaderboard", canvas.width / 2, canvas.height / 2 + 120);

      // Show buttons
      document.getElementById("restartBtn").style.display = "inline-block";
      document.getElementById("viewRecordsBtn").style.display = "inline-block";
      settingsBtn.style.display = "inline-block";
    }

    function renderGameOverScreen() {
      // Background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, "#660000");
      gradient.addColorStop(1, "#330000");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Game over text
      ctx.fillStyle = "white";
      ctx.font = "60px monospace";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 3);

      // Animated blood drips
      ctx.fillStyle = "#8B0000";
      for (let i = 0; i < 10; i++) {
        const x = canvas.width / 2 - 200 + i * 40;
        const y = canvas.height / 3 + 20;
        const height = 50 + Math.sin(Date.now() / 500 + i) * 30;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 10, y);
        ctx.lineTo(x + 5, y + height);
        ctx.closePath();
        ctx.fill();
      }

      // Death message
      ctx.fillStyle = "white";
      ctx.font = "30px sans-serif";
      ctx.fillText("You have been defeated!", canvas.width / 2, canvas.height / 2);

      // Instructions
      ctx.font = "20px sans-serif";
      ctx.fillText("Click 'Restart' to try again", canvas.width / 2, canvas.height / 2 + 50);

      // Show restart button
      document.getElementById("restartBtn").style.display = "inline-block";
      settingsBtn.style.display = "inline-block";
    }

    // ===== LEVEL DEFINITIONS =====

    // Old Kingdom Level
    levels[0] = {
      name: "Old Kingdom",
      width: 4800, // Reduced from 6400
      height: 3600, // Reduced from 4800
      goonDensity: 1,
      background: {
        sky: "#87CEEB", // Light blue sky
        ground: "#7CFC00", // Green grass
        mountains: "#8B4513", // Brown mountains
        trees: "#228B22", // Forest green trees
      },
      npcs: [
        {
          x: 1200,
          y: 1600,
          type: "talk",
          dialog:
            "The ghost of the goon haunts these lands. Follow the river north. Be careful, the goons have become more aggressive lately!",
        },
        {
          x: 2400,
          y: 800,
          type: "shop",
          dialog: "Buy a gun for 5 coins? Press E to buy.",
          cost: 5,
        },
        {
          x: 4000,
          y: 2200,
          type: "talk",
          dialog: "The castle lies beyond the desert. Many have tried to defeat the boss, but none have returned.",
        },
        {
          x: 3800,
          y: 3000,
          type: "talk",
          dialog:
            "You're nearing the edge of the Old Kingdom. The Desert Realm awaits, with its scorching heat and dangerous creatures.",
        },
      ],

      // Level-specific initialization
      init: function () {
        // Add any level-specific initialization here
      },

      // Render level background
      renderBackground: function (ctx) {
        const bg = this.background;

        // Sky gradient
        const skyGradient = ctx.createLinearGradient(0, 0, 0, this.height - 400);
        skyGradient.addColorStop(0, bg.sky);
        skyGradient.addColorStop(1, "#FFFFFF");
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, this.width, this.height - 400);

        // Draw river
        ctx.fillStyle = "#4682B4"; // Steel blue water
        ctx.beginPath();
        ctx.moveTo(0, 1800);
        // Winding river path
        for (let x = 0; x < this.width; x += 400) {
          const y = 1800 + Math.sin(x / 800) * 300;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(this.width, 1500);
        ctx.lineTo(this.width, 1700);
        // Return path
        for (let x = this.width; x > 0; x -= 400) {
          const y = 1800 + Math.sin(x / 800) * 300 + 200;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(0, 2000);
        ctx.closePath();
        ctx.fill();

        // Draw river highlights
        ctx.strokeStyle = "#87CEFA"; // Light sky blue
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let x = 0; x < this.width; x += 100) {
          const y = 1800 + Math.sin(x / 800) * 300 + Math.sin(x / 100 + Date.now() / 1000) * 20;
          if (x === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();

        // Mountains in background
        ctx.fillStyle = bg.mountains;
        for (let i = 0; i < 20; i++) {
          const mountainHeight = 400 + Math.sin(i * 0.7) * 200;
          const mountainWidth = 1200;
          const x = i * 600;
          ctx.beginPath();
          ctx.moveTo(x, this.height - 400 - mountainHeight);
          ctx.lineTo(x + mountainWidth / 2, this.height - 400);
          ctx.lineTo(x + mountainWidth, this.height - 400 - mountainHeight);
          ctx.closePath();
          ctx.fill();
        }

        // Ground
        ctx.fillStyle = bg.ground;
        ctx.fillRect(0, this.height - 400, this.width, 400);

        // Trees or environment objects
        for (let i = 0; i < 100; i++) {
          const treeHeight = 150 + (i % 5) * 20; // Use deterministic height based on index
          const treeWidth = 80;
          const x = i * 200; // Fixed x position based on index
          const y = this.height - 400 - treeHeight;

          // Only render trees that are visible (optimization)
          if (!camera.isVisible({ x, y, width: treeWidth, height: treeHeight }, 200)) {
            continue;
          }

          // Tree trunk
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(x + treeWidth / 3, y + treeHeight / 2, treeWidth / 3, treeHeight / 2);

          // Tree top
          ctx.fillStyle = bg.trees;
          ctx.beginPath();
          ctx.moveTo(x, y + treeHeight / 2);
          ctx.lineTo(x + treeWidth / 2, y);
          ctx.lineTo(x + treeWidth, y + treeHeight / 2);
          ctx.closePath();
          ctx.fill();

          ctx.beginPath();
          ctx.moveTo(x, y + treeHeight / 3);
          ctx.lineTo(x + treeWidth / 2, y - treeHeight / 4);
          ctx.lineTo(x + treeWidth, y + treeHeight / 3);
          ctx.closePath();
          ctx.fill();
        }

        // Add some flowers and grass details
        for (let i = 0; i < 500; i++) {
          const x = (i * 37) % this.width; // Deterministic x position
          const y = this.height - 400 + (i * 17) % 50; // Deterministic y position

          // Only render flowers that are visible (optimization)
          if (!camera.isVisible({ x, y, width: 10, height: 10 }, 200)) {
            continue;
          }

          const size = 5 + (i % 10); // Deterministic size

          // Fixed flower colors based on position
          const colors = ["#FF69B4", "#FF1493", "#FFA500", "#FFFF00", "#9370DB"];
          const color = colors[i % colors.length];

          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }

        // Add landmarks for navigation
        // Castle in the distance
        ctx.fillStyle = "#444";
        ctx.fillRect(this.width - 800, this.height - 800, 300, 400);
        // Tower
        ctx.fillStyle = "#555";
        ctx.fillRect(this.width - 650, this.height - 1000, 100, 600);
        // Flag on tower
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.moveTo(this.width - 600, this.height - 1000);
        ctx.lineTo(this.width - 500, this.height - 950);
        ctx.lineTo(this.width - 600, this.height - 900);
        ctx.closePath();
        ctx.fill();

        // Add signposts for direction
        for (let i = 0; i < 5; i++) {
          const x = i * 1000 + 500;
          const y = this.height - 350;

          // Post
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(x, y, 10, 50);

          // Sign
          ctx.fillStyle = "#DEB887";
          ctx.fillRect(x - 30, y - 20, 70, 30);

          // Arrow
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.moveTo(x + 30, y - 5);
          ctx.lineTo(x + 50, y - 5);
          ctx.lineTo(x + 50, y - 15);
          ctx.lineTo(x + 70, y + 5);
          ctx.lineTo(x + 50, y + 25);
          ctx.lineTo(x + 50, y + 15);
          ctx.lineTo(x + 30, y + 15);
          ctx.closePath();
          ctx.fill();
        }
      },

      // Render any additional level-specific elements
      render: function (ctx) {
        // Add any level-specific rendering here
      },
    };

    // Desert Realm Level
    levels[1] = {
      name: "Desert Realm",
      width: 4800, // Reduced from 6400
      height: 3600, // Reduced from 4800
      goonDensity: 2, // More goons than Old Kingdom
      background: {
        sky: "#FFD700", // Golden sky
        ground: "#F4A460", // Sandy brown
        mountains: "#D2B48C", // Tan mountains
        trees: "#DAA520", // Golden rod (desert plants)
      },
      npcs: [
        {
          x: 800,
          y: 1200,
          type: "talk",
          dialog:
            "In the heat of the desert, the ghost roams. Seek the oasis to the east. The goons are stronger here, be careful!",
        },
        {
          x: 3200,
          y: 2400,
          type: "shop",
          dialog: "Upgrade your gun for 10 coins? Press E to buy.",
          cost: 10,
        },
        {
          x: 3800,
          y: 1600,
          type: "talk",
          dialog: "The oasis is just ahead. It's the last source of water before the Frozen Tundra. Rest while you can.",
        },
      ],

      // Level-specific initialization
      init: function () {
        // Create oasis
        this.oasis = {
          x: 3500,
          y: 2000,
          width: 800,
          height: 600,
          healingPower: 1, // Health restored per frame when player is in oasis
        };
      },

      // Render level background
      renderBackground: function (ctx) {
        const bg = this.background;

        // Sky gradient
        const skyGradient = ctx.createLinearGradient(0, 0, 0, this.height - 400);
        skyGradient.addColorStop(0, bg.sky);
        skyGradient.addColorStop(0.7, "#FFA07A"); // Light salmon for desert horizon
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, this.width, this.height - 400);

        // Draw sun
        ctx.fillStyle = "#FF4500"; // Orange-red sun
        ctx.beginPath();
        ctx.arc(this.width / 2, 500, 200, 0, Math.PI * 2);
        ctx.fill();

        // Sun rays
        ctx.strokeStyle = "#FF8C00"; // Dark orange
        ctx.lineWidth = 5;
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const x1 = this.width / 2 + Math.cos(angle) * 220;
          const y1 = 500 + Math.sin(angle) * 220;
          const x2 = this.width / 2 + Math.cos(angle) * 350;
          const y2 = 500 + Math.sin(angle) * 350;

          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }

        // Desert dunes
        for (let i = 0; i < 30; i++) {
          const duneHeight = 100 + Math.sin(i * 0.5) * 50;
          const duneWidth = 800;
          const x = i * 400 - 200;

          // Only render dunes that are visible (optimization)
          if (x + duneWidth < camera.x || x > camera.x + camera.width) {
            continue;
          }

          ctx.fillStyle = "#F4A460"; // Sandy brown
          ctx.beginPath();
          ctx.moveTo(x, this.height - 400);
          ctx.quadraticCurveTo(x + duneWidth / 2, this.height - 400 - duneHeight, x + duneWidth, this.height - 400);
          ctx.lineTo(x + duneWidth, this.height);
          ctx.lineTo(x, this.height);
          ctx.closePath();
          ctx.fill();

          // Dune highlights
          ctx.fillStyle = "#DEB887"; // Burlywood (lighter sand)
          ctx.beginPath();
          ctx.moveTo(x, this.height - 400);
          ctx.quadraticCurveTo(
            x + duneWidth / 2,
            this.height - 400 - duneHeight,
            x + duneWidth / 2 + 100,
            this.height - 400 - duneHeight / 2,
          );
          ctx.lineTo(x + duneWidth / 2 + 100, this.height - 400);
          ctx.lineTo(x, this.height - 400);
          ctx.closePath();
          ctx.fill();
        }

        // Ground
        ctx.fillStyle = bg.ground;
        ctx.fillRect(0, this.height - 400, this.width, 400);

        // Draw oasis
        if (this.oasis) {
          // Water
          ctx.fillStyle = "#4169E1"; // Royal blue water
          ctx.beginPath();
          ctx.ellipse(
            this.oasis.x + this.oasis.width / 2,
            this.oasis.y + this.oasis.height / 2,
            this.oasis.width / 2,
            this.oasis.height / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Water ripples
          ctx.strokeStyle = "#87CEFA"; // Light sky blue
          ctx.lineWidth = 2;
          for (let i = 1; i <= 3; i++) {
            ctx.beginPath();
            ctx.ellipse(
              this.oasis.x + this.oasis.width / 2,
              this.oasis.y + this.oasis.height / 2,
              this.oasis.width / 2 - i * 20,
              this.oasis.height / 2 - i * 15,
              0,
              0,
              Math.PI * 2,
            );
            ctx.stroke();
          }

          // Palm trees around oasis
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const x = this.oasis.x + this.oasis.width / 2 + Math.cos(angle) * (this.oasis.width / 2 + 50);
            const y = this.oasis.y + this.oasis.height / 2 + Math.sin(angle) * (this.oasis.height / 2 + 50);

            // Tree trunk
            ctx.fillStyle = "#8B4513"; // Saddle brown
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(
              x + Math.cos(angle + 0.2) * 30,
              y + Math.sin(angle + 0.2) * 30 - 80,
              x + Math.cos(angle) * 10,
              y - 150,
            );
            ctx.lineTo(x + Math.cos(angle) * 15, y - 145);
            ctx.quadraticCurveTo(
              x + Math.cos(angle - 0.2) * 30,
              y + Math.sin(angle - 0.2) * 30 - 80,
              x + 5,
              y,
            );
            ctx.closePath();
            ctx.fill();

            // Palm leaves
            ctx.fillStyle = "#228B22"; // Forest green
            for (let j = 0; j < 5; j++) {
              const leafAngle = angle + (j * Math.PI) / 3;
              ctx.beginPath();
              ctx.moveTo(x + Math.cos(angle) * 10, y - 150);
              ctx.quadraticCurveTo(
                x + Math.cos(angle) * 10 + Math.cos(leafAngle) * 40,
                y - 150 + Math.sin(leafAngle) * 40,
                x + Math.cos(angle) * 10 + Math.cos(leafAngle) * 80,
                y - 150 + Math.sin(leafAngle) * 80,
              );
              ctx.quadraticCurveTo(
                x + Math.cos(angle) * 10 + Math.cos(leafAngle) * 40 + Math.cos(leafAngle + 0.5) * 20,
                y - 150 + Math.sin(leafAngle) * 40 + Math.sin(leafAngle + 0.5) * 20,
                x + Math.cos(angle) * 10,
                y - 150,
              );
              ctx.closePath();
              ctx.fill();
            }
          }
        }

        // Cacti
        for (let i = 0; i < 50; i++) {
          const x = (i * 91) % this.width;
          const y = this.height - 400 + (i * 23) % 50;

          // Only render cacti that are visible (optimization)
          if (x < camera.x - 50 || x > camera.x + camera.width + 50) {
            continue;
          }

          const height = 80 + (i % 3) * 10;
          const width = 20 + (i % 5);

          // Main cactus body
          ctx.fillStyle = "#2E8B57"; // Sea green
          ctx.fillRect(x, y - height, width, height);

          // Cactus arms
          if (Math.random() > 0.3) {
            const armHeight = 30 + Math.random() * 50;
            const armWidth = width * 0.8;
            const armY = y - height + 20 + Math.random() * (height - 40);

            // Left or right arm
            const isLeftArm = Math.random() > 0.5;
            const armX = isLeftArm ? x - armWidth : x + width;

            ctx.fillRect(armX, armY, armWidth, armWidth / 2);
            ctx.fillRect(
              isLeftArm ? armX : armX + armWidth - armWidth / 2,
              armY - armHeight + armWidth / 2,
              armWidth / 2,
              armHeight,
            );
          }
        }

        // Add landmarks for navigation
        // Pyramid in the distance
        ctx.fillStyle = "#DAA520";
        ctx.beginPath();
        ctx.moveTo(this.width - 800, this.height - 400);
        ctx.lineTo(this.width - 600, this.height - 800);
        ctx.lineTo(this.width - 400, this.height - 400);
        ctx.closePath();
        ctx.fill();

        // Oasis sign
        ctx.fillStyle = "#4169E1";
        ctx.fillRect(100, this.height - 600, 100, 50);
        ctx.fillStyle = "white";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Oasis ->", 150, this.height - 570);
        ctx.textAlign = "left";
      },

      // Render any additional level-specific elements
      render: function (ctx) {
        // Check if player is in oasis and heal them
        if (this.oasis && checkCollision(player, this.oasis)) {
          if (player.health < player.maxHealth) {
            player.health = Math.min(player.maxHealth, player.health + this.oasis.healingPower);

            // Healing particles
            for (let i = 0; i < 3; i++) {
              const x = player.x + Math.random() * player.width;
              const y = player.y + Math.random() * player.height;

              ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
              ctx.beginPath();
              ctx.arc(x, y, 5, 0, Math.PI * 2);
              ctx.fill();
            }

            // Healing text
            ctx.fillStyle = "green";
            ctx.font = "14px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("+1", player.x + player.width / 2, player.y - 10);
            ctx.textAlign = "left";
          }
        }
      },
    };

    // Frozen Tundra Level
    levels[2] = {
      name: "Frozen Tundra",
      width: 4800, // Reduced from 6400
      height: 3600, // Reduced from 4800
      goonDensity: 3, // More goons than Desert Realm
      background: {
        sky: "#B0E0E6", // Powder blue sky
        ground: "#F0FFFF", // Snow white
        mountains: "#A9A9A9", // Dark gray mountains
        trees: "#008080", // Teal (pine trees)
      },
      npcs: [
        {
          x: 1000,
          y: 1400,
          type: "talk",
          dialog:
            "The cold hides many secrets. The ghost is near the ice cave. Watch your step, the ice is slippery and goons are everywhere.",
        },
        {
          x: 3000,
          y: 2800,
          type: "shop",
          dialog: "Buy warm clothes for 15 coins? They will protect you from the cold. Press E to buy.",
          cost: 15,
        },
        {
          x: 3800,
          y: 1800,
          type: "talk",
          dialog:
            "The castle entrance is just ahead. No one has ever returned from there. Are you sure you want to proceed?",
        },
      ],

      // Level-specific initialization
      init: function () {
        // Create ice cave
        this.iceCave = {
          x: 3000,
          y: 1500,
          width: 800,
          height: 600,
        };

        // Create ice patches (slippery areas)
        this.icePatches = [];
        for (let i = 0; i < 20; i++) {
          this.icePatches.push({
            x: Math.random() * (this.width - 500),
            y: Math.random() * (this.height - 500),
            width: 300 + Math.random() * 500,
            height: 200 + Math.random() * 300,
          });
        }
      },

      // Render level background
      renderBackground: function (ctx) {
        const bg = this.background;

        // Sky gradient
        const skyGradient = ctx.createLinearGradient(0, 0, 0, this.height - 400);
        skyGradient.addColorStop(0, bg.sky);
        skyGradient.addColorStop(1, "#E0FFFF"); // Light cyan
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, this.width, this.height - 400);

        // Northern lights
        ctx.globalAlpha = 0.3;
        for (let i = 0; i < 5; i++) {
          const y = 200 + i * 100;
          const colors = ["#00FF00", "#00FFFF", "#FF00FF", "#FFFF00"];
          const color = colors[i % colors.length];

          ctx.strokeStyle = color;
          ctx.lineWidth = 50;
          ctx.beginPath();
          ctx.moveTo(0, y);

          for (let x = 0; x < this.width; x += 100) {
            const waveHeight = Math.sin(x / 500 + i + Date.now() / 5000) * 100;
            ctx.lineTo(x, y + waveHeight);
          }

          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;

        // Snow-covered mountains
        ctx.fillStyle = "#FFFFFF";
        for (let i = 0; i < 20; i++) {
          const mountainHeight = 600 + Math.sin(i * 0.7) * 200;
          const mountainWidth = 1200;
          const x = i * 600;

          // Only render mountains that are visible (optimization)
          if (x + mountainWidth < camera.x || x > camera.x + camera.width) {
            continue;
          }

          // Mountain base
          ctx.fillStyle = bg.mountains;
          ctx.beginPath();
          ctx.moveTo(x, this.height - 400 - mountainHeight * 0.8);
          ctx.lineTo(x + mountainWidth / 2, this.height - 400);
          ctx.lineTo(x + mountainWidth, this.height - 400 - mountainHeight * 0.8);
          ctx.closePath();
          ctx.fill();

          // Snow cap
          ctx.fillStyle = "#FFFFFF";
          ctx.beginPath();
          ctx.moveTo(x, this.height - 400 - mountainHeight * 0.8);
          ctx.lineTo(x + mountainWidth / 2, this.height - 400 - mountainHeight);
          ctx.lineTo(x + mountainWidth, this.height - 400 - mountainHeight * 0.8);
          ctx.closePath();
          ctx.fill();
        }

        // Ground (snow)
        ctx.fillStyle = bg.ground;
        ctx.fillRect(0, this.height - 400, this.width, 400);

        // Draw ice patches
        ctx.fillStyle = "rgba(135, 206, 250, 0.5)"; // Light sky blue with transparency
        for (const patch of this.icePatches) {
          // Only render ice patches that are visible (optimization)
          if (!camera.isVisible(patch, 100)) {
            continue;
          }

          ctx.beginPath();
          ctx.ellipse(
            patch.x + patch.width / 2,
            patch.y + patch.height / 2,
            patch.width / 2,
            patch.height / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Ice reflections
          ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(
            patch.x + patch.width / 2,
            patch.y + patch.height / 2,
            patch.width / 2 - 20,
            patch.height / 2 - 15,
            0,
            0,
            Math.PI * 2,
          );
          ctx.stroke();
        }

        // Draw ice cave
        if (this.iceCave) {
          // Cave entrance
          ctx.fillStyle = "#000033"; // Dark blue
          ctx.beginPath();
          ctx.ellipse(
            this.iceCave.x + this.iceCave.width / 2,
            this.iceCave.y + this.iceCave.height / 2,
            this.iceCave.width / 2,
            this.iceCave.height / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Ice formations around cave
          ctx.fillStyle = "#ADD8E6"; // Light blue
          for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2;
            const x = this.iceCave.x + this.iceCave.width / 2 + (Math.cos(angle) * this.iceCave.width) / 2;
            const y = this.iceCave.y + this.iceCave.height / 2 + (Math.sin(angle) * this.iceCave.height) / 2;
            const height = 50 + Math.random() * 100;
            const width = 20 + Math.random() * 30;

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - width / 2, y + height);
            ctx.lineTo(x + width / 2, y + height);
            ctx.closePath();
            ctx.fill();
          }
        }

        // Pine trees
        for (let i = 0; i < 100; i++) {
          const x = (i * 47) % this.width;
          const y = this.height - 400 + (i * 19) % 50;

          // Only render trees that are visible (optimization)
          if (x < camera.x - 100 || x > camera.x + camera.width + 100) {
            continue;
          }

          const height = 150 + (i % 7) * 10;

          // Tree trunk
          ctx.fillStyle = "#8B4513"; // Saddle brown
          ctx.fillRect(x - 10, y - height / 4, 20, height / 4);

          // Tree branches (triangles stacked)
          ctx.fillStyle = bg.trees;
          for (let j = 0; j < 3; j++) {
            const triangleHeight = height / 3;
            const triangleWidth = 100 - j * 20;
            const triangleY = y - height / 4 - j * triangleHeight;

            ctx.beginPath();
            ctx.moveTo(x, triangleY - triangleHeight);
            ctx.lineTo(x - triangleWidth / 2, triangleY);
            ctx.lineTo(x + triangleWidth / 2, triangleY);
            ctx.closePath();
            ctx.fill();
          }

          // Snow on branches
          ctx.fillStyle = "#FFFFFF";
          for (let j = 0; j < 3; j++) {
            const triangleHeight = height / 3;
            const triangleWidth = 100 - j * 20;
            const triangleY = y - height / 4 - j * triangleHeight;

            ctx.beginPath();
            ctx.moveTo(x, triangleY - triangleHeight + 10);
            ctx.lineTo(x - triangleWidth / 2 + 10, y - 5);
            ctx.lineTo(x + triangleWidth / 2 - 10, y - 5);
            ctx.closePath();
            ctx.fill();
          }
        }

        // Add landmarks for navigation
        // Ice cave in the distance
        ctx.fillStyle = "#000033";
        ctx.beginPath();
        ctx.ellipse(this.width - 800, this.height - 400, 200, 100, 0, 0, Math.PI * 2);
        ctx.fill();

        // Frozen lake
        ctx.fillStyle = "#ADD8E6";
        ctx.fillRect(100, this.height - 600, 300, 200);
        ctx.fillStyle = "white";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Frozen Lake", 250, this.height - 500);
        ctx.textAlign = "left";

        // Castle sign
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(this.width - 200, 100, 100, 50);
        ctx.fillStyle = "white";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Castle ->", this.width - 150, 130);
        ctx.textAlign = "left";

        // Falling snow
        if (graphicsQuality !== "low") {
          ctx.fillStyle = "#FFFFFF";
          for (let i = 0; i < 200; i++) {
            const x = (camera.x + Math.random() * camera.width) + Math.sin(Date.now() / 1000 + i) * 50;
            const y = (camera.y + Math.random() * camera.height) + Math.cos(Date.now() / 1000 + i * 2) * 50;
            const size = 1 + Math.random() * 3;

            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      },

      // Render any additional level-specific elements
      render: function (ctx) {
        // Check if player is on ice and make them slide
        for (const patch of this.icePatches) {
          if (checkCollision(player, patch)) {
            // Visual indicator that player is on ice
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + player.height + 10, 20, 0, Math.PI * 2);
            ctx.fill();

            // Apply sliding effect (continue movement in the same direction)
            if (keys["ArrowUp"]) player.y -= 1;
            if (keys["ArrowDown"]) player.y += 1;
            if (keys["ArrowLeft"]) player.x -= 1;
            if (keys["ArrowRight"]) player.x += 1;

            break;
          }
        }
      },
    };

    // Castle Level (Boss Fight)
    levels[3] = {
      name: "Castle Dungeon",
      width: 6400, // Smaller than other levels to keep boss fight focused
      height: 4800,
      goonDensity: 0.5, // Fewer goons than other levels
      walls: [], // Will be populated in init

      // Boss definition
      boss: {
        x: 3200,
        y: 2400,
        width: 100,
        height: 100,
        hp: 50,
        maxHp: 50,
        color: "purple",
        speed: 80, // pixels per second
        attackRange: 300,
        attackCooldown: 0,
        attackRate: 1500,
        damage: 10,
        attackProjectiles: [],
        state: "idle", // idle, chasing, attacking
        lastStateChange: 0,
        stateDuration: 3000,
        // Animation
        animationFrame: 0,
        animationTimer: 0,
        animationSpeed: 200,
      },

      // Level-specific initialization
      init: function () {
        // Initialize castle walls
        this.initCastleWalls();

        // Create health potions
        this.healthPotions = [
          { x: 1000, y: 1000, width: 30, height: 30, healing: 20 },
          { x: 5400, y: 3800, width: 30, height: 30, healing: 20 },
        ];

        // Reset boss
        this.boss.hp = this.boss.maxHp;
        this.boss.attackProjectiles = [];
        this.boss.state = "idle";
        this.boss.lastStateChange = 0;
      },

      initCastleWalls: function () {
        this.walls = [];

        // Outer walls
        this.walls.push({ x: 0, y: 0, width: this.width, height: 100, color: "#8B4513" }); // Top
        this.walls.push({ x: 0, y: this.height - 100, width: this.width, height: 100, color: "#8B4513" }); // Bottom
        this.walls.push({ x: 0, y: 0, width: 100, height: this.height, color: "#8B4513" }); // Left
        this.walls.push({ x: this.width - 100, y: 0, width: 100, height: this.height, color: "#8B4513" }); // Right

        // Inner walls (maze-like structure)
        this.walls.push({ x: 1000, y: 1000, width: 4400, height: 100, color: "#8B4513" });
        this.walls.push({ x: 1000, y: 3800, width: 4400, height: 100, color: "#8B4513" });
        this.walls.push({ x: 1000, y: 1000, width: 100, height: 2900, color: "#8B4513" });
        this.walls.push({ x: 5400, y: 1000, width: 100, height: 2900, color: "#8B4513" });

        // Add some pillars
        this.walls.push({ x: 2000, y: 2000, width: 200, height: 200, color: "#8B4513" });
        this.walls.push({ x: 4200, y: 2000, width: 200, height: 200, color: "#8B4513" });
      },

      // Update boss behavior
      updateBoss: function (deltaTime) {
        if (!this.boss) return;

        // Update boss animation
        this.boss.animationTimer += deltaTime;
        if (this.boss.animationTimer >= this.boss.animationSpeed) {
          this.boss.animationFrame = (this.boss.animationFrame + 1) % 4;
          this.boss.animationTimer = 0;
        }

        // Update boss state
        this.boss.lastStateChange += deltaTime;
        if (this.boss.lastStateChange > this.boss.stateDuration) {
          // Change state
          if (this.boss.state === "idle") {
            this.boss.state = Math.random() > 0.5 ? "chasing" : "attacking";
          } else {
            this.boss.state = "idle";
          }
          this.boss.lastStateChange = 0;
        }

        // Calculate distance to player
        const dx = player.x - this.boss.x;
        const dy = player.y - this.boss.y;
        const distanceToPlayer = Math.sqrt(dx * dx + dy * dy);

        // Boss behavior based on state
        switch (this.boss.state) {
          case "idle":
            // Just stay in place
            break;

          case "chasing":
            // Move toward player if not too close
            if (distanceToPlayer > 150) {
              const angle = Math.atan2(dy, dx);
              const moveDistance = this.boss.speed * (deltaTime / 1000);
              const newBossX = this.boss.x + Math.cos(angle) * moveDistance;
              const newBossY = this.boss.y + Math.sin(angle) * moveDistance;

              // Check if boss would collide with walls
              const bossRect = {
                x: newBossX,
                y: this.boss.y,
                width: this.boss.width,
                height: this.boss.height,
              };

              if (!this.walls.some((wall) => checkCollision(bossRect, wall))) {
                this.boss.x = newBossX;
              }

              bossRect.x = this.boss.x;
              bossRect.y = newBossY;

              if (!this.walls.some((wall) => checkCollision(bossRect, wall))) {
                this.boss.y = newBossY;
              }
            }
            break;

          case "attacking":
            // Attack with projectiles
            this.boss.attackCooldown -= deltaTime;
            if (this.boss.attackCooldown <= 0 && distanceToPlayer < this.boss.attackRange) {
              // Create multiple projectiles in a spread pattern
              const baseAngle = Math.atan2(dy, dx);
              const spreadCount = 5;

              for (let i = 0; i < spreadCount; i++) {
                const spreadAngle = baseAngle - 0.4 + (i / (spreadCount - 1)) * 0.8;

                this.boss.attackProjectiles.push({
                  x: this.boss.x + this.boss.width / 2,
                  y: this.boss.y + this.boss.height / 2,
                  radius: 15,
                  speed: 160, // pixels per second
                  angle: spreadAngle,
                  color: "red",
                });
              }

              this.boss.attackCooldown = this.boss.attackRate;
            }
            break;
        }

        // Update boss projectiles
        for (let i = this.boss.attackProjectiles.length - 1; i >= 0; i--) {
          const proj = this.boss.attackProjectiles[i];
          const moveDistance = proj.speed * (deltaTime / 1000);
          proj.x += Math.cos(proj.angle) * moveDistance;
          proj.y += Math.sin(proj.angle) * moveDistance;

          // Check if projectile hits player
          const distance = Math.sqrt(
            Math.pow(proj.x - (player.x + player.width / 2), 2) + Math.pow(proj.y - (player.y + player.height / 2), 2),
          );

          if (distance < proj.radius + player.width / 2) {
            // Player takes damage if not invulnerable
            if (!player.invulnerable && !godMode) {
              player.health -= this.boss.damage;
              player.invulnerable = true;
              player.invulnerableTimer = player.invulnerableDuration;

              // Create hit particles
              createParticles(
                player.x + player.width / 2,
                player.y + player.height / 2,
                10,
                "red",
                0.8,
                500
              );

              // Game over if player health reaches 0
              if (player.health <= 0) {
                gameState = "over";
                document.getElementById("restartBtn").style.display = "inline-block";
              }
            }

            // Remove projectile
            this.boss.attackProjectiles.splice(i, 1);
          }

          // Remove projectiles that hit walls or go off-screen
          else if (proj.x < 0 || proj.x > this.width || proj.y < 0 || proj.y > this.height ||
            this.walls.some(wall => checkCollision(proj, wall))) {
            this.boss.attackProjectiles.splice(i, 1);
          }
        }

        // Check collision with boss (direct damage if touching)
        if (checkCollision(player, this.boss) && !player.invulnerable && !godMode) {
          player.health -= this.boss.damage * 2; // Double damage for direct contact
          player.invulnerable = true;
          player.invulnerableTimer = player.invulnerableDuration;

          // Create hit particles
          createParticles(
            player.x + player.width / 2,
            player.y + player.height / 2,
            10,
            "red",
            0.8,
            500
          );

          // Game over if player health reaches 0
          if (player.health <= 0) {
            gameState = "over";
            document.getElementById("restartBtn").style.display = "inline-block";
          }
        }

        // Check health potions
        for (let i = this.healthPotions.length - 1; i >= 0; i--) {
          if (checkCollision(player, this.healthPotions[i])) {
            const healing = this.healthPotions[i].healing;
            player.health = Math.min(player.maxHealth, player.health + healing);
            this.healthPotions.splice(i, 1);
            showNotification(`+${healing} Health`);
          }
        }
      },

      // Render level background
      renderBackground: function (ctx) {
        // Castle floor
        ctx.fillStyle = "#A9A9A9"; // Dark gray
        ctx.fillRect(0, 0, this.width, this.height);

        // Floor pattern
        ctx.strokeStyle = "#696969"; // Dim gray
        ctx.lineWidth = 1;

        // Only draw floor pattern for visible area (optimization)
        const startX = Math.floor(camera.x / 100) * 100;
        const startY = Math.floor(camera.y / 100) * 100;
        const endX = Math.ceil((camera.x + camera.width) / 100) * 100;
        const endY = Math.ceil((camera.y + camera.height) / 100) * 100;

        for (let x = startX; x < endX; x += 100) {
          for (let y = startY; y < endY; y += 100) {
            ctx.strokeRect(x, y, 100, 100);
          }
        }

        // Add some blood stains and debris
        ctx.save();
        ctx.globalAlpha = 0.3;

        // Use a fixed seed for consistent random patterns
        const pseudoRandom = (x, y) => {
          return (((Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1) + 1) % 1;
        };

        for (let x = startX; x < endX; x += 200) {
          for (let y = startY; y < endY; y += 200) {
            if (pseudoRandom(x, y) > 0.7) {
              // Blood stain
              ctx.fillStyle = "#8B0000"; // Dark red
              ctx.beginPath();
              ctx.ellipse(
                x + pseudoRandom(x, y + 1) * 100,
                y + pseudoRandom(x + 1, y) * 100,
                20 + pseudoRandom(x, y + 2) * 30,
                10 + pseudoRandom(x + 2, y) * 20,
                0,
                0,
                Math.PI * 2,
              );
              ctx.fill();
            } else if (pseudoRandom(x, y) < 0.2) {
              // Debris/rocks
              ctx.fillStyle = "#696969"; // Dim gray
              ctx.beginPath();
              ctx.rect(
                x + pseudoRandom(x, y + 3) * 100,
                y + pseudoRandom(x + 3, y) * 100,
                10 + pseudoRandom(x, y + 4) * 15,
                10 + pseudoRandom(x + 4, y) * 15,
              );
              ctx.fill();
            }
          }
        }

        ctx.restore();
      },

      // Render any additional level-specific elements
      render: function (ctx) {
        // Draw walls
        for (const wall of this.walls) {
          ctx.fillStyle = wall.color;
          ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
        }

        // Draw health potions
        for (const potion of this.healthPotions) {
          // Potion bottle
          ctx.fillStyle = "#FF0000"; // Red
          ctx.beginPath();
          ctx.ellipse(
            potion.x + potion.width / 2,
            potion.y + potion.height / 2,
            potion.width / 2,
            potion.height / 2,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Bottle highlight
          ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
          ctx.beginPath();
          ctx.ellipse(
            potion.x + potion.width / 3,
            potion.y + potion.height / 3,
            potion.width / 6,
            potion.height / 6,
            0,
            0,
            Math.PI * 2,
          );
          ctx.fill();

          // Health cross symbol
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(potion.x + potion.width / 2, potion.y + potion.height / 4);
          ctx.lineTo(potion.x + potion.width / 2, potion.y + (potion.height * 3) / 4);
          ctx.moveTo(potion.x + potion.width / 4, potion.y + potion.height / 2);
          ctx.lineTo(potion.x + (potion.width * 3) / 4, potion.y + potion.height / 2);
          ctx.stroke();
        }
      },

      // Render boss
      renderBoss: function (ctx) {
        if (!this.boss) return;

        // Boss body
        ctx.fillStyle = this.boss.color;
        ctx.fillRect(this.boss.x, this.boss.y, this.boss.width, this.boss.height);

        // Boss crown
        ctx.fillStyle = "gold";
        ctx.beginPath();
        ctx.moveTo(this.boss.x, this.boss.y);
        ctx.lineTo(this.boss.x + this.boss.width / 2, this.boss.y - 30);
        ctx.lineTo(this.boss.x + this.boss.width, this.boss.y);
        ctx.closePath();
        ctx.fill();

        // Boss eyes
        ctx.fillStyle = "white";
        ctx.fillRect(this.boss.x + this.boss.width / 4, this.boss.y + this.boss.height / 4, 15, 15);
        ctx.fillRect(this.boss.x + (this.boss.width * 3) / 4 - 15, this.boss.y + this.boss.height / 4, 15, 15);

        ctx.fillStyle = "red";
        ctx.fillRect(this.boss.x + this.boss.width / 4 + 3, this.boss.y + this.boss.height / 4 + 3, 9, 9);
        ctx.fillRect(this.boss.x + (this.boss.width * 3) / 4 - 12, this.boss.y + this.boss.height / 4 + 3, 9, 9);

        // Boss mouth
        ctx.fillStyle = "black";
        ctx.fillRect(this.boss.x + this.boss.width / 4, this.boss.y + (this.boss.height * 2) / 3, this.boss.width / 2, 8);

        // Draw boss projectiles
        for (const proj of this.boss.attackProjectiles) {
          ctx.fillStyle = proj.color;
          ctx.beginPath();
          ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      },

      // Render minimap (empty for boss level)
      renderMinimap: function (ctx) {
        // No minimap for boss level
      },
    };

    // Initialize game
    window.addEventListener("load", () => {
      // Initialize game
      initGame();
    });

    function initGame() {
      // Load settings
      loadSettings();

      // Check for saved game
      const savedGame = loadGameProgress();
      if (savedGame && !savedGame.completed) {
        document.getElementById("continueBtn").style.display = "inline-block";
      }

      // Start game loop
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>

</html>
